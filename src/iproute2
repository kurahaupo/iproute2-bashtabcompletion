#! library/module/for/bash
#
# ip (iproute2) command-line completion for Bash.
#
# Written by Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Released at LCA2010, 19 January 2010.
#
# You may copy and use this program under the terms of version two of the Gnu Public Licence, or
# any later version as published by the Free Software Foundation.
#

[[ $(type -t have) != function ]] || have ip || return

__ip_slurp()
{
    sed -e '
             s/#.*//
             s/[ 	][ 	]*/ /g
             s/ $//
             s/^[0-9][0-9]* //
             /^$/d
             s/ /\n/g
            ' $1
}

__ip_strtrunc()
{
    local w=$1 ; shift
    local p="$*"
    ((${#p} > w)) && p="${p:0:w-3}..."
    echo "$p"
}

__ip_debug() { : ; }
__ip_debug_parsing_state() { : ; }
__ip_debug_unexpected() { : ; }
__ip_error() { : ; }
__ip_warning() { : ; }

__ip_complete_address()
{
    local maybe_ipv4=false maybe_ipv6=false maybe_prefix=false nsp=true \
          require_prefix=false possibly_complete=false definitely_complete=false last_term_complete=false \
          require_multicast=false \
          last_term

    while (($#)) ; do  case $1 in
    (--) shift ; break ;;
    (-0) echo >&2 "Option '-0' not implemented" ; return 64 ;;
    (-4) maybe_ipv4=true ;;
    (-6) maybe_ipv6=true ;;
    (-p) maybe_prefix=true ;;
    (-P) require_prefix=true ;;
    (-m) require_multicast=true ;;
    (-*) ;;
    (*) break ;;
    esac ; shift ; done
    local cur=$1

    __ip_debug "Completing address starting with '$cur': ipv4=$maybe_ipv4 ipv6=$maybe_ipv6 prefix=$maybe_prefix/$require_prefix "

    if $require_prefix && [[ $cur = d* || $cur = ::/0 || $cur = 0.0.0.0/0 ]]
    then
        __ip_warning "Expecting a non-default prefix"
        COMPREPLY=(default\ )
        return 0
    fi

    [[ $cur = *::* ]] && possibly_complete=true
    [[ $cur = *:*:*:*:*:*:*:* || $cur = *.*.*.* ]] && possibly_complete=true definitely_complete=true
    [[ $cur = *[:a-f]* || $cur = [0-9][0-9][0-9][0-9]* ]] && maybe_ipv4=false
    [[ $cur = *.* ]] && maybe_ipv6=false

    $COMP_VERBOSE && echo >&2 $'\e[A\e[2K\r'"Completing address starting with '$cur': ipv4=$maybe_ipv4 ipv6=$maybe_ipv6 prefix=$maybe_prefix/$require_prefix possibly-complete=$possibly_complete definitely-complete=$definitely_complete"

    # sanity check
    $maybe_ipv4 || $maybe_ipv6 || {
        __ip_warning "Invalid address; neither IPv4 nor IPv6 possible"
        return 1
    }

    case $cur in
    (.* \
    |*..* \
    |*.*.*.*.* \
    |*:::* \
    |*:*:*:*:*:*:*:*:* \
    |*/*[:./]* \
    |*.*[:a-f]* \
    |*[:a-f]*.* \
    |*[^/.:0-9a-f]* )
        __ip_debug "Address '$cur' is neither valid IPv4 nor valid IPv6"
        return 1 ;;
    esac

    [[ ${cur%/*} = *[:a-f]* ]] && ! $maybe_ipv6 && {
        __ip_debug "Invalid IPv4 address $cur"
        return 1
    }
    [[ ${cur%/*} = *.* ]] && ! $maybe_ipv4 && {
        __ip_debug "Invalid IPv6 address $cur"
        return 1
    }

    local d19 d09 d0f dot col slash
    d19="${cur}1 ${cur}2 ${cur}3 ${cur}4 ${cur}5 ${cur}6 ${cur}7 ${cur}8 ${cur}9"
    d09="${cur}0 $d19"
    d0f="$d09 ${cur}a ${cur}b ${cur}c ${cur}d ${cur}e ${cur}f"
    dot=$cur.
    col=$cur:
    slash=$cur/

    COMPREPLY=()

    if [[ $cur = */* ]]
    then
        local pref_len=${cur##*/} \
              max_pref_len=32
        $maybe_ipv6 && max_pref_len=128

        [[ $pref_len = *[^0-9]* ]] && {
            __ip_error "Prefix-length '$pref_len' is non-numeric"
            return 1
        }
        (( pref_len > max_pref_len )) && {
            __ip_error "Prefix-length '$pref_len' is greater than $max_pref_len"
            return 1
        }

        if (( pref_len * 10 > max_pref_len ))
        then
            __ip_warning "Prefix length is greater than ${max_pref_len%?}, therefore we're finished"
            nsp=false
            COMPREPLY+=($cur)
        else
            COMPREPLY+=($d09)
        fi
    else
        local last_term=${cur##*[:.]}

        if $require_multicast && [[ $cur = $last_term ]]
        then
            COMPREPLY=( $( compgen -W "224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 ffc0::" -- $cur ) )
            __ip_debug "Start of multicast range"
            return 0
        fi

        if $maybe_ipv6
        then [[ $last_term = [0-9a-f][0-9a-f][0-9a-f][0-9a-f] ]]
        else $maybe_ipv4 &&
             [[ $last_term != *[^0-9]* &&
                $last_term = [0-9]* ]] &&
             (( last_term >= 26 || last_term == 0 ))
        fi && last_term_complete=true

        if $last_term_complete
        then
            $possibly_complete && nsp=false
        elif $maybe_ipv6
        then COMPREPLY+=($d0f)
        elif [[ $last_term = '' ]]
        then COMPREPLY+=($d09)
        else COMPREPLY+=($d19)
        fi

        $maybe_prefix && $possibly_complete && COMPREPLY+=($slash) nsp=true

        if ! $definitely_complete
        then
            $maybe_ipv4 && [[ .$cur != *. ]] && COMPREPLY+=($dot)
            $maybe_ipv6 && [[ $cur != *:: && $cur != *::*: ]] && COMPREPLY+=($col)
            nsp=true
        fi

    fi

    __ip_debug "Completed last-term=$last_term (last-term-definitely-complete=$last_term_complete) no-space=$nsp compreply=[$(__ip_strtrunc 20 "${COMPREPLY[*]}")] (count=${#COMPREPLY[*]})"

    ((${#COMPREPLY[@]} == 0)) && {
        __ip_debug "No matches for '$cur'"
        return 1
    }

    # completion treats colons as if they were word-separators, and appends to current word rather than replacing it
    [[ $cur = *:* ]] &&
    for ((i=0 ; i<${#COMPREPLY[@]} ; i++ )) do
        COMPREPLY[i]="${COMPREPLY[i]#${cur%:*}:}"
    done

    ((${#COMPREPLY[@]} == 1)) && ! $nsp && COMPREPLY="$COMPREPLY "

    return 0
}

_ip()
{
    local -a expect
    local cur i options seen

    COMPREPLY=()

    if $COMP_VERBOSE
    then
        echo >&2 $'\e7\e[A\e[999I\e[43;30m\e[1J\e[H'"Completion START: WORDS=(${COMP_WORDS[*]}) CWORD=$COMP_CWORD"
        trap " trap RETURN ; echo -n >&2 'Completion END: COMPREPLY=('\${COMPREPLY[*]}')'\$'\\e[49;39;0m\\e8' " RETURN
        __ip_debug() { echo >&2 "Completion $*" ; }
        __ip_debug_parsing_state() { echo >&2 "Completion STATE $*word[$i]: seen=$seen curr=$cur expect=(${expect[*]})" ; }
        __ip_debug_unexpected() { echo >&2 "Completion UNEXPECTED $*" ; }
        __ip_error() { echo >&2 "Completion ERROR $*" ; }
        __ip_warning() { echo >&2 "Completion WARNING $*" ; }
    else
        __ip_debug() { : ; }
        __ip_debug_parsing_state() { : ; }
        __ip_debug_unexpected() { : ; }
        __ip_error() { local t="$*" ; local l=${#t} ; echo -n >&2 $'\e[1K\e[33m'$t$'\e[39m\e['$l'D' ; }
        __ip_warning() { : ; }
    fi

    # Establish parsing state:
    seen=START expect=(START) cur="(start-of-line)"
    __ip_debug_parsing_state
    for ((i=1;i<COMP_CWORD;i++)) do
        cur=${COMP_WORDS[i]}

        context=$expect ; unset expect[0] ; expect=("${expect[@]}")

        __ip_debug "Matching on \"$expecting:$cur\""
        # If we're expecting a specific word
        if [[ $context = ="$cur"* ]] ; then
            # process word based on seen state rather than on the explicit expectation
            context=$seen
        elif [[ $context = =* ]] ; then
            # didn't find it!
            __ip_error "Expecting '${context#=}' instead of '$cur'"
            return 1
        fi

        __ip_debug "Matching on \"$seen:$cur\""
        case $context:$cur in

        (START:-f*\
        |START:--f*)    expect=(FAMILY START) ;;
        (START:-*) ;;

        (START:a*)      seen=addr ;;
        (START:l*)      seen=link ;;
        (START:ma*)     seen=maddr ;;
        (START:mo*)     seen=monitor ;;
        (START:mr*)     seen=mroute ;;
        (START:ne*)     seen=neigh ;;
        (START:nt*)     seen=ntable ;;
        (START:ro*)     seen=route ;;
        (START:ru*)     seen=rule ;;
        (START:t*)      seen=tunnel ;;
        (START:x*)      seen=xfrm ;;

        (addr:a*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # add
        (addr:c*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # change
        (addr:d*)       seen=addr_D expect=(ADDR =dev DEVICE) ;; # del
        (addr:f*)       seen=addr_S                           ;; # flush
        (addr:l*)       seen=addr_S                           ;; # list (alias for show)
        (addr:r*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # replace
        (addr:s*)       seen=addr_S                           ;; # show

        (addr_?:a*)     expect=(ADDR)   ;; # anycast
        (addr_?:b*)     expect=(ADDR)   ;; # broadcast
        (addr_?:dep*)                   ;; # deprecated
        (addr_?:dy*)                    ;; # dynamic
        (addr_?:d*)     expect=(DEVICE) ;; # dev
        (addr_?:h*)                     ;; # home
        (addr_?:l*)     expect=(LABEL)  ;; # label
        (addr_?:n*)                     ;; # nodad
        (addr_?:per*)                   ;; # permanent
        (addr_?:p*)     expect=(PREFIX) ;; # peer
        (addr_?:pre*)   expect=(LFT)    ;; # preferred_lft
        (addr_?:pri*)                   ;; # primary
        (addr_?:se*)                    ;; # secondary
        (addr_?:s*)     expect=(SCOPE)  ;; # scope
        (addr_?:te*)                    ;; # tentative
        (addr_?:t*)     expect=(PREFIX) ;; # to
        (addr_?:v*)     expect=(LFT)    ;; # valid_lft

        (link:l*)       seen=link_L expect=(DEVICE) ;;  # list (alias for show)
        (link:se*)      seen=link_S  expect=(DEVICE) ;;
        (link:sh*)      seen=link_L expect=(DEVICE) ;;

        (link_S:ad*)    expect=(LLADDR)  ;; # address
        (link_S:al*)    expect=(ONOFF)   ;; # allmulticast
        (link_S:ar*)    expect=(ONOFF)   ;; # arp
        (link_S:b*)     expect=(LLADDR)  ;; # broadcast
        (link_S:d*)                      ;; # down
        (link_S:dy*)    expect=(ONOFF)   ;; # dynamic
        (link_S:mt*)    expect=(NUMBER32) ;; # mtu
        (link_S:mu*)    expect=(ONOFF)   ;; # multicast
        (link_S:n*)     expect=(NEWNAME) ;; # name
        (link_S:p*)     expect=(ONOFF)   ;; # promisc
        (link_S:tr*)    expect=(ONOFF)   ;; # trailers
        (link_S:tx*)    expect=(NUMBER8) ;; # txqueuelen
        (link_S:u*)                      ;; # up

        (maddr:a*)      seen=maddr_add  expect=(MADDR =dev DEVICE) ;;
        (maddr:d*)      seen=maddr_del  expect=(MADDR =dev DEVICE) ;;
        (maddr:s*)      seen=maddr_show expect=(      =dev DEVICE) ;;

        (monitor:*)     ;;

        (mroute:[sl]*)  seen=mroute_S expect=(PREFIX) ;; # list, show
        (mroute_S:f*)   expect=(PREFIX) ;;  # from
        (mroute_S:i*)   expect=(DEVICE) ;;  # iif

        (neigh:a*)      seen=neigh_A expect=(ADDR) ;; # add
        (neigh:c*)      seen=neigh_A expect=(ADDR) ;; # change
        (neigh:d*)      seen=neigh_A expect=(ADDR) ;; # del
        (neigh:f*)      seen=neigh_S    ;; # flush
        (neigh:l*)      seen=neigh_S    ;; # list, alias for show
        (neigh:r*)      seen=neigh_A expect=(ADDR) ;; # replace
        (neigh:s*)      seen=neigh_S    ;; # show
        (neigh_A:*)     expect=(ADDR) ;;
        (neigh_S:*)     ;;

        (ntable:*)      seen=ntable_$cur ;;

        (route:a*)      seen=route_A    ;; # add/append
        (route:c*)      seen=route_A    ;; # change
        (route:d*)      seen=route_A    ;; # del
        (route:f*)      seen=route_L    ;; # flush
        (route:g*)      seen=route_G expect=(ADDR) ;; # get
        (route:l*)      seen=route_L    ;; # list
        (route:m*)      seen=route_A    ;; # monitor
        (route:r*)      seen=route_A    ;; # replace
        (route:s*)      seen=route_L    ;; # show (alias for list)

        (route_L:e*)    expect=(PREFIX) ;; # exact
        (route_L:m*)    expect=(PREFIX) ;; # match
        (route_L:p*)    expect=(RTPROTO) ;; # proto
        (route_L:r*)    expect=(PREFIX) ;; # root
        (route_L:s*)    expect=(SCOPE)  ;; # scope
        (route_L:ta*)   expect=(TABLE+)  ;; # table
        (route_L:ty*)   expect=(RTYPE)  ;; # type

        (route_G:f*)    expect=(ADDR =iif IFACE) ;; # from
        (route_G:i*)    expect=(IFACE)  ;; # iif
        (route_G:o*)    expect=(IFACE)  ;; # oif
        (route_G:t*)    expect=(TOS)    ;; # tos

        (route_A:b[lr]*\
        |route_A:[lmnpt]*\
        |route_A:un[ir]*) seen=route_P expect=(PREFIX) ;;  # still seen route-add-type, now expecting PREFIX-[TTPSM], then [INFO_SPEC]

        (route_A:*)     seen=route_P    ;; # seen route-add-[type]-prefix

        (route_P:a*)    expect=(NUMBER16) ;; # advmss
        (route_P:c*)    expect=(NUMBER32) ;; # cwnd
        (route_P:d*)    expect=(IFACE)  ;; # dev
        (route_P:e*)                    ;; # equalize
        (route_P:i*)    expect=(NUMBER32) ;; # initcwnd
        (route_P:me*)   expect=(NUMBER31S) ;; # metric
        (route_P:mt*)   expect=(NUMBER32) ;; # mtu
        (route_P:n*)                    ;; # nexthop
        (route_P:o*)                    ;; # onlink
        (route_P:pr*)   expect=(RTPROTO) ;; # proto
        (route_P:pe*)                   ;; # pervasive
        (route_P:re*)   expect=(REALM)  ;; # realms
        (route_P:rto*)  expect=(TIME)   ;; # rto_min
        (route_P:rtt*)  expect=(TIME)   ;; # rtt or rttvar
        (route_P:sc*)   expect=(SCOPE)  ;; # scope
        (route_P:sr*)   expect=(ADDR)   ;; # src
        (route_P:ss*)   expect=(NUMBER) ;; # ssthresh
        (route_P:ta*)   expect=(TABLE)  ;; # table
        (route_P:to*)   expect=(TOS)    ;; # tos
        (route_P:v*)    expect=(ADDR)   ;; # via
        (route_P:we*)   expect=(NUMBER16) ;; # weight
        (route_P:wi*)   expect=(NUMBER8) ;; # window

        (rule:[ad]*)    seen=rule_A     ;; # add/del
        (rule:[lfs]*)   seen=rule_L     ;; # flush/list/show
        (rule_A:d*)     expect=(DEVICE) ;; # dev
        (rule_A:fr*)    expect=(PREFIX) ;; # from
        (rule_A:fw*)    expect=(NUMBER32) ;; # fwmark
        (rule_A:g*)     expect=(NUMBER) ;; # goto
        (rule_A:i*)     expect=(DEVICE) ;; # iif
        (rule_A:l*)     expect=(TABLE)  ;; # lookup=table
        (rule_A:n*)                     ;; # not
        (rule_A:pre*)   expect=(NUMBER) ;; # pref
        (rule_A:pri*)   expect=(NUMBER) ;; # prio
        (rule_A:pro*)                   ;; # prohibit
        (rule_A:rea*)   expect=(REALM)  ;; # realm
        (rule_A:rej*)                   ;; # reject
        (rule_A:ta*)    expect=(TABLE)  ;; # table
        (rule_A:to)     expect=(PREFIX) ;; # to
        (rule_A:tos)    expect=(TOS)    ;; # tos
        (rule_A:u* )                    ;; # unreachable

        (tunnel:*)      seen=tunnel_${cur:0:1} ;;

        (DEVICE:*)      save_device=$cur ;;
        ([A-Z]*:*)      ;;

        (*)             __ip_error "Lost sync? seen=$seen expect=$context cur=$cur" ; return 1 ;;

        esac
        : ${expect:=${seen%/*}}

        __ip_debug_parsing_state
    done
    cur=$(_get_cword)

    local nsp=false or_digits=false max_num= min_num=

    case $expect in
    (START) options=( addr link maddr monitor mroute neigh ntable route rule \
                      tunnel xfrm --details --family --oneline --resolve \
                      --statistics --timestamp --verbose --Version -0 -4 -6 \
                      -d -f -o -r -s -t -v -V ) ;;

    (addr)  options=( add change flush del list show replace monitor ) ;;
    (addr_A)
            options=( anycast broadcast deprecated dev dynamic home label \
                      nodad peer permanent preferred_lft primary scope \
                      secondary tentative to valid_lft ) ;;
    (addr_D)
            options=( dev ) ;;
    (addr_S)
            options=( anycast broadcast deprecated dev dynamic home label \
                      nodad peer permanent primary scope secondary tentative \
                      to ) ;;

    (link)  options=( list show set ) ;;
    (link_S)
            options=( address allmulticast arp broadcast down dynamic mtu \
                      multicast name promisc trailers txqueuelen up ) ;;

    (maddr) options=( add del list show ) ;;

    (monitor)
            options=( all addr link maddr mroute neigh ntable route rule tunnel xfrm ) ;;

    (mroute)
            options=( list show ) ;;

    (neigh)
            options=( add change del replace ) ;;

    (ntable)
            options=( change ) ;;

    (route) options=( add append change del flush get list show replace monitor ) ;;
    (route_G)
            options=( from oif tos ) ;;
    (route_L)   # RTSELECTOR
            options=( root match exact table proto type scope ) ;;
    (route_A)   # ROUTE -> NODE_SPEC -> [TYPE] PREFIX
            options=( via dev weight unicast local broadcast multicast \
                      throw unreachable prohibit blackhole nat default \
                      ...PREFIX... ) ;;
    (route_P)   # ROUTE -> NODE_SPEC -> [TYPE] PREFIX
            options=( advmss cwnd dev equalize initcwnd metric mtu nexthop \
                      proto realms rto_min rtt rttvar scope src ssthresh \
                      table tos via weight window ) ;;

    (rule)  options=( add del flush list show ) ;;
    (rule_A)
            options=( dev from fwmark goto iif lookup not pref prio prohibit \
                      realms reject table to tos unreachable ) ;;
    (rule_L)
            options=() nsp=false ;;

    (tunnel)
            options=( add change del list show ) ;;

    (xfrm)  options=( policy state monitor ) ;;

    (=*)    options=( ${expect#=} ) ;;

    (DEVICE)
            #options=( '$( a=(/proc/sys/net/ipv?/conf/*) ; echo "${a[@]##*/}" )' ) ;;
            options=( '$(ip -o link list | sed -e "s/^[0-9]*: //; s/: .*//; /^wmaster/d" )' ) ;;
    (FAMILY)
            options=( inet inet6 ipx dnet link ) ;;
    (LFT)   options=( forever ) or_digits=true max_num=255 ;;
    (NUMBER)
            options=() or_digits=true ;;
    (NUMBER8)
            options=() or_digits=true max_num=0xff ;;
    (NUMBER16)
            options=() or_digits=true max_num=0xffff ;;
    (NUMBER32)
            options=() or_digits=true max_num=0xffffffff ;;
    (NUMBER31S)
            options=() or_digits=true min_num=-0x80000000 max_num=0x7fffffff ;;
    (ONOFF) options=( on off ) ;;
    (REALM) options=( '$(__ip_slurp /etc/iproute2/rt_realms)' )
            or_digits=true max_num=0xff ;;
    (SCOPE) options=( '$( __ip_slurp /etc/iproute2/rt_scopes )' ) ;;
    (ADDR)  __ip_complete_address -4 -6 $cur ; return $? ;;
    (MADDR) __ip_complete_address -m -4 -6 $cur ; return $? ;;
    (LLADDR)
            options=( 00:00:00:00:00:00 ... ) ;;
    (PREFIX)
            __ip_complete_address -P -4 -6 $cur ; return $? ;;
    (LABEL) options=( $save_device: ) nsp=true ;;
    (TABLE) options=( default local main '$( __ip_slurp /etc/iproute2/rt_tables )' )
            or_digits=true max_num=255 ;;
    (TABLE+)
            options=( all default local main '$( __ip_slurp /etc/iproute2/rt_tables )' )
            or_digits=true max_num=255 min_num=-2 ;;
    (RTYPE) options=( blackhole broadcast local multicast nat prohibit throw \
                      unicast unreachable ) ;;
    (RTPROTO)
            options=( boot kernel static ) or_digits=true max_num=255 ;;
    (TOS)   options=( inherit ) or_digits=true max_num=255 ;;

    (K_options) ;;
    (*)     options=( "Undefined:$expect" )
    esac
    __ip_debug "COMPREPLY=[${COMPREPLY[*]}] or_digits=$or_digits cur=$cur"

    if $or_digits && [[ ${cur#-} != *[^0-9]* ]]
    then
        [[ $cur != '-' ]] && options+=( ${cur} )
        if (( (!${#max_num} || cur*10 <= max_num) &&
              (!${#min_num} || cur*10 >= min_num) ))
        then options+=( ${cur}0 ${cur}1 ${cur}2 ${cur}3 ${cur}4 \
                        ${cur}5 ${cur}6 ${cur}7 ${cur}8 ${cur}9 )
        else nsp=false
        fi
    fi

    COMPREPLY=( $( compgen -W "${options[*]}" -- $cur ) )

    ((${#COMPREPLY[@]} == 1)) && ! $nsp && COMPREPLY="$COMPREPLY "

    return 0
}
COMP_VERBOSE=false
complete -F _ip -o nospace ip
