#! library/module/for/bash
#
# ip (iproute2) command-line completion for Bash.
#
# Written by Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Released at LCA2010, 19 January 2010.
# Updated to use a parser state-stack April 2012.
# Improved clean-up-at-exit Feb 2019
# Progressively updated for different versions of the "ip" command
#
# You may copy and use this program under the terms of version three of the Gnu
# Public Licence, or any later version as published by the Free Software
# Foundation.
#
# Set COMP_VERBOSE to any non-null value to enable debugging output; unset it
# to disable.
#

[[ $(type -t have) != function ]] || have ip || return

_ip() {

    [[  $true = 1 ]] || local -ri  true=1
    [[ $false = 0 ]] || local -ri false=0

    case $COMP_TYPE in
    (63) ((++__ip_comp_count >= 3)) && COMP_TYPE=best ;;
    (9)  ((__ip_comp_count=1)) ;;
    (*)  ((__ip_comp_count=0)) ;;
    esac
    COMP_WORDBREAKS="${COMP_WORDBREAKS//:/}"

    # "expecting" is stack of partial states, as a string separated by slashes,
    # shallowest-to-deepest
    local STATE=
    local cur="(start-of-line)"
    local cword_index=0
    local save_device=
    local save_family='-Fdual'
    local want=
    local max_num= min_num=
    local expecting=
    local __ip_seen_PREFIX=false

    # Too hard to localize everything, so clean up upon return
    # All functions named as __ip__cleanup* will be called in collation order.
    # All functions and variables named as __ip_* will be unset
    __ip__cleanup() {
        trap RETURN
        local __ip__c
        local -a __ip__cc
        while IFS=$' \t\n' read -ra __ip__cc <&3
        do
            for __ip__c in "${__ip__cc[@]}"
            do
                [[ $__ip__c = __ip__cleanup?* ]] && "$__ip__c"
                [[ $__ip__c = __ip_* ]] && unset -f "$__ip__c"
            done
        done 3< <( declare -F )
        for __ip__c in "${__ip_cleanup[@]}"; do "$__ip__c" ; unset -f "$__ip__c" ; done
        unset "${!__ip_@}"

        unset -f __ip__cleanup
    }
    __ip__cleanup
    trap __ip__cleanup RETURN

    #
    # If the function "cluck" is defined, use it; otherwise display the given
    # message, with a stack trace using the "caller" built-in (if available).
    #
    __ip_cluck() {
        ${COMP_VERBOSE:+:} false || return
        if [[ $( type -t cluck ) = function ]]
        then
            (cluck "$@" 2>&1)
        elif [[ $( type -t caller ) = builtin ]]
        then
            echo "$*"
            local l d
            for ((l=1;l<20;l++)) do
                d=$( caller $l ) && [[ -n $d ]] || break
                echo "    $d"
            done
            echo
        else
            echo "$*"
        fi >&3
    }

    #
    # Read in the contents of a file, minus comments
    # Avoid external commands (such as sed).
    #
    __ip_slurp() {
        local l
        while read l
        do  l=${l//$'\t'/' '}          # squash tabs and spaces
            l=${l//'                '/' '} # ''
            l=${l//'        '/' '}     # ''
            l=${l//'    '/' '}         # ''
            l=${l//'  '/' '}           # ''
            l=${l%%'#'*}               # strip comments
            l=${l#"${l%%[^0-9]*} "}    # strip leading word comprised entirely of digits
            [[ -n $l ]] || continue
            echo "$l"
        done <$1
        return
    }

    #
    # The __ip_match* family of functions attempt to match various patterns
    #
    # They rely on three global variables: COMP_WORDS[], COMP_CWORD & cword_index.
    # (When cword_index equals COMP_CWORD, this is the "focal" word, so generate a
    # full list of possible matches; otherwise we're just parsing before the focal
    # word, so just do basic checking, and stash the value if requested.)
    #
    # The only time they return "true" is when they have *the only* possible match,
    # and that generally means only for non-focus words.
    #
    # __ip_match NUM [--[signed-]N-bit] [--max=N] [--min=N]
    #                   [-A | -Bauto | -BN]
    #                   [-Iprefix] [-Ssuffix] [-V[varname]]

    __ip_chk_NUM() {
        __ip_debug "CHECKNUM $*"
        if
            [[ $__val = ?*     && $__val != *[^0-9]*      ]] ||
            [[ $__radix = auto && $__val = 0x?* && $__val != 0x*[^0-9a-f]* ]] ||
            [[ $__radix = 16   && $__val != *[^0-9a-f]*   ]]
        then
            (( __val += 0 ))
            return 0
        else
            (( __val = 0 ))
            return 1
        fi
    }

    __ip_exp_NUM() {
        local -a __digits=( 0 1 2 3 4 5 6 7 8 9
                            a b c d e f g h i j k l m n o p q r s t u v w x y z
                            A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                            @ _ )
        __ip_debug "MATCHNUM min=$__min max=$__max radix=$__radix prefix=$__ignore_prefix suffix=$__suffix $*"
        if [[ ${__radix:?'Radix not set!'} = auto ]]
        then
            case $__val in
            (0x*) __radix=16 ;;
            (0*)  __radix=8 ;;
            (*)   __radix=10 ;;
            esac
        fi

        __val=${__val#0x} __val=${__val#${__val%%[^0]*}}
        if (( ${#__neg} & 1 ))
        then
            case $__min:$__max in
            (:?*)   ((__min=-__max)) ; __max= ;;
            (*?:)   ((__max=-__min)) ; __min= ;;
            (*?:?*) eval "(( __min=-($__max), __min=-($__min) )) " ;;
            esac
        fi

        # No non-digits allowed
        # Check that it contains no disallowed digits
        if  [[ $__val = *[^${__digits[*]:0:__radix}]* || $__val = *' '* ]]
        then
            __ip_unexpected "MATCHNUM $__val not suitable for radix $__radix"
            return 1
        fi

        # TODO Use a better algorithm here

        local __i
        (( __i = $__radix#$__val ))

        (( __min <= __i && __i <= __max )) && COMPREPLY=( "${COMPREPLY[@]}" "$__cur$__suffix" )

        local __min_digit __max_digit

        (( __offset = __i * __radix ))
        while
            (( __min_digit = (${#__min}==0 || __min < __offset ? 0 : __min - __offset),
               __max_digit = (${#__max}==0 || __max >= __offset+__radix ? __radix-1 : __max - __offset ) ))
            (( __min_digit >= __radix ))
        do
            __ip_debug "MATCHNUM: $__cur->$__val->$__i radix=$__radix offset=$__offset (min=$__min max=$__max)" \
                                  "-> (min_digit=$__min_digit max_digit=$__max_digit) RETRY"
            (( __min/=__radix, __max/=__radix ))
        done
        __ip_debug "MATCHNUM: $__cur->$__val->$__i radix=$__radix offset=$__offset (min=$__min max=$__max)" \
                              "-> (min_digit=$__min_digit max_digit=$__max_digit)"

        for ((__i=__min_digit;__i<=__max_digit;++__i)) do
            COMPREPLY=( "${COMPREPLY[@]}" "${__cur}${__digits[__i]}" )
        done
    }

    #
    # __ip_match ANY [-R[KEY]] [-S[SUFFIX]] [-V[VARNAME]] [MATCH-LIST...]
    #
    # The MATCH-LIST elements are of the form [MATCH=]TOKEN or MATCH=[TOKEN]=GROUP.
    # The TOKEN is included in COMPREPLY (which means it may replace a partially
    # typed ALIAS); GROUP is used to set the -V parameter (if set).
    #

    __ip_chk_ANY() {
        #__ip_debug "CHECK seen=$__skip_seen seen_pref=$__seen_pref set_var=$__set_var val=$__val WORDS=($*)"
        for _p do
            _t="${_p%%=*}"
            [[ $_t = "$__val"* ]] || continue
            _p="${_p#*=}"
            $__skip_seen && {
                _q="${_p#*=}"
                _q="$__seen_pref${_q//[^_0-9a-zA-Z]/__}"
                #__ip_debug "Remembering that $_p has been seen (setting $_q=true)"
                eval $_q=true
            }
            _p="${_p%%=*}"
            _p="${_p:-$_t}"
            __val="$_p"
            return 0
        done
        return 1
    }

    __ip_exp_ANY() {
        #__ip_debug "MATCH seen=$__skip_seen seen_pref=$__seen_pref set_var=$__set_var val=$__val WORDS=($*)"
        for _p do
            _t="${_p%%=*}"
            [[ $_t = "$__val"* ]] || continue
            _p="${_p#*=}"
            $__skip_seen && {
                _q="${_p#*=}"
                _q="$__seen_pref${_q//[^_0-9a-zA-Z]/__}"
                eval \${$_q:+:} false && continue
            }
            _p="${_p%%=*}"
            _p="${_p:-$_t}"
            COMPREPLY=( "${COMPREPLY[@]}" "$_p$__suffix" )
            #[[ $COMP_TYPE = best ]] && return 0  # Unfortunately this doesn't get used;
                                                  # after the first tab-key, the shell will always show a list, even if it (now)
                                                  # has only one member
        done
    }

    __ip_chk_ADDR() {
        $accept_prefix && [[ $__val = */* && $__val != */*[^0-9]* ]] && __val=${__val%/*}
        { $accept_default && [[ default = "$__val"* ]] ; } ||
        { $accept_ipv6   && [[ $__val = *::* || $__val = *:*:*:*:*:*:*:* || $__val = *:*:*:*:*:*:*.*.*.* ]] ; } ||
        { $accept_ipv4   && [[ $__val = *.*.*.* && $__val != *:* ]] ; } ||
        { $accept_link   && [[ $__val = ??:??:??:??:??:?? ]] ; } || {
            __ip_warning "Cannot match '$__val' as requested type of address"
            return 1
        }
    }

    __ip_exp_ADDR() {
        # Accept "default" keyword, if appropriate
        if $accept_default
        then
            __ip_match ANY default
            return
        fi

        if $accept_prefix
        then
            __ip_debug "Looking for prefix"
            case $__val in
            (*:*/*) __ip_match NUM -I'*/' -B10 --min=1 --max=128 ; return ;;
            (*/*)   __ip_match NUM -I'*/' -B10 --min=1 --max=32  ; return ;;
            (*.*.*.*?|*::|*::*:*?|*:*:*:*:*:*:*:*) __ip_match CUR -S/ ;;
            esac
        else
            case $__val in
            (*/*)   __ip_warning "Prefix not allowed" ;; # return ;;
            esac
        fi

        if $accept_link
        then
            __ip_debug "Looking for link-layer MAC (Ethernet) address"
            case :$__val in
            (*::*|*:?:*|*[^:][^:][^:]*|*[^0-9a-f:]*) ;;
            (:??:??:??:??:??:??) __ip_match CUR ;;
            (*:??)              __ip_match CUR -S: ;;
            (*)                 __ip_match NUM -I'*:' -B16 --8bit ;;
            esac
        fi

        if $accept_ipv6
        then
            __ip_debug "Looking for IPv6 address"

            __ip_match ANY -S'' fe80:: fc00:: :: ::1

            # one 16-bit block
            case $__val in
            (*:*:*:*:*:*:*:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]) __ip_match CUR ;;                      # whole last block?
            (*:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]) __ip_match CUR    -S: ;;                           # whole middle block?
            (*:*:*:*:*:*:*:*)   __ip_match NUM -I'*:' -B16 --16bit     ;;                           # last block?
            (*:*)               __ip_match NUM -I'*:' -B16 --16bit -S: ;;                           # middle block
            (*)                 __ip_match NUM        -B16 --16bit -S: --min=0x2000 --max=0x3fff ;; # first block?
            esac

            # embedded IPv4?
            case $__val in
            (::*.*.*.*) __ip_match NUM -I'*.'    -A --8bit ;;
            (::*:*) ;;
            (::*)       __ip_match NUM -I'*[:.]' -A --8bit -S. ;;
            esac

            # complete as-is?
            [[ ( $__val = *:*:*:*:*:*:*:*? || $__val = *::*? ) && $__val != *. ]] && __ip_match CUR -S' '

        fi

        if $accept_ipv4
        then
            __ip_debug "Looking for IPv4 address"
            case $__val in
            (*:*)       ;;
            (*.*.*.*)   __ip_match NUM -I'*.' -A --8bit ;;
            (*)         __ip_match NUM -I'*.' -A --8bit -S. ;;
            esac
        fi
    }

    __ip_match_addr() {
      # __ip_match ADDR "$@"
      # return $?
        local accept_link= accept_ipv4= accept_ipv6= \
              accept_prefix=false accept_default=false \
              require_multicast=false require_unicast=false
        local __set_var=
        local __skip_seen=false _R= __seen_pref= _p

        while [[ $1 = -* ]]
        do
            case $1 in
            ( -Fdual )          accept_ipv4=true accept_ipv6=true ;;
            ( -Finet  )         accept_ipv4=true ;;
            ( -Finet6  )        accept_ipv6=true ;;
            ( -Flink  )         accept_link=true ;;
          # ( -F*)              __ip_unexpected "Family '${1#-?}' is not supported" ; return 0 ;;
            ( -m )              require_multicast=true ;;
            ( -p )              accept_prefix=true ;;
            ( -pd )             accept_prefix=true accept_default=true ;;
            ( -R* )             __skip_seen=true _R=$1 _p=${1#-?}
                                __seen_pref=__ip_seen_${_p:-${expecting//[^_0-9a-zA-Z]/__}}___ ;;
            ( -V* )             _p=${1#-?} __set_var=${_p:-_V} ;;
            (*)                 __ip_error "Invalid option '$1' to __ip_match_addr" ; break 3 ;;
            esac
            shift
        done
        : ${accept_link:=false} ${accept_ipv4=false} ${accept_ipv6=false}

        local __cur="${COMP_WORDS[cword_index]}"
        local __val="${__cur##$__ignore_prefix}"

        __ip_debug "Completing address starting with '$__cur'; will accept" $(
                        for w in ipv4 ipv6 prefix link ; do eval \$accept_$w && echo $w ; done
                    )

        # Reject impossible things...
        if [[ ( $__cur = *[^0-9a-f:./]* && default != "$__cur"* ) ||
              $__cur = *:*:*:*:*:*:*:*:* ||
              $__cur = *:::* ||
              $__cur = *::*::* ||
              $__cur = *.*.*.*.* ||
              $__cur = *.*[^0-9./]* ||
              $__cur = */*[^0-9]* ]]
        then
            __ip_warning "Cannot match '$__cur' as any type of address"
            return 1
        fi

        if ((cword_index==COMP_CWORD))
        then
            __ip_debug "EXPAND-ADDR $*"
            __ip_exp_ADDR "$@"
            return 1
        else
            __ip_debug "CHECK-ADDR $*"
            __ip_chk_ADDR "$@" || return $?
            [[ -n $__set_var ]] && {
                __ip_debug "SETVAR saving ADDR '$__cur' into $__set_var"
                eval "$__set_var=\"\$__cur\""
            }
            return 0
        fi
    }

    #
    # __ip_match_empty and __ip_match_failed may be called when other matching
    # functions return non-zero; they take some rather peculiar action as a result:
    #
    # * 'break' will cause the match loop will cease and possible completions
    #   computed so far (COMPREPLY) will be used
    # * 'break 2' will cause all processing will immediately stop, and no
    #   completions will be available
    # * 'decrement cword_index and continue' will cause the match loop will start
    #   over, testing the same word against the previous non-terminal, adding to
    #   the possible completions computed so far (COMPREPLY).
    #

    __ip_match_empty()  {
        __ip_debug_parsing_state "MATCH-EMPTY(1) $expecting"
        ((--cword_index))
        continue
    }

    __ip_match_failed() {
        if ((__empty))
        then
            # treat same as __ip_match_empty
            __ip_debug_parsing_state "MATCH-EMPTY(2) $expecting"
            ((--cword_index))
            continue
        elif ((cword_index==COMP_CWORD))
        then
            __ip_debug_parsing_state "MATCH-LAST $expecting"
            break
        fi

        __ip_debug_parsing_state "MATCH-FAILED $expecting"
        __ip_cluck -x -s -S0 "MATCH-FAILED $expecting BACKTRACE"
        break 2
    }

    __ip_chk_CUR() {
        true
    }

    __ip_exp_CUR() {
        COMPREPLY=( "${COMPREPLY[@]}" "$__cur$__suffix" )
    }

    __ip_match() {
        local _w="$1" ; shift

        local __skip_seen=false _R= __seen_pref=
        local __set_var=
        local __max= __min=0 __radix=auto
        local __ignore_prefix= __suffix=' '
        local _p _q _t

        while [[ $1 = -* ]]
        do
            case $1 in
            ( --[0-9]*bit )     (( _p=${1//[^0-9]/}, __min=0, __max=(1<<_p)-1)) ;;
            ( --max*=* )        __max=${1#--*=} ;;
            ( --min*=* )        __min=${1#--*=} ;;
            ( --s*[0-9]*bit )   (( _p=${1//[^0-9]/}-1, __min=-1<<_p, __max=(1<<_p)-1)) ;;
            ( -A )              __radix=auto ;;
            ( -B?* )            __radix=${1#-?} ;;
            ( -I* )             __ignore_prefix=${1#-?} ;;
            ( -R* )             __skip_seen=true _R=$1 _p=${1#-?}
                                __seen_pref=__ip_seen_${_p:-${expecting//[^_0-9a-zA-Z]/__}}___ ;;
            ( -S* )             __suffix=${1#-?} ;;
            ( -V* )             _p=${1#-?} __set_var=${_p:-_V} ;;
            (*)                 __ip_error "Invalid option '$1' to __ip_match[$_w]" ;;
            esac
            shift
        done

        local __cur="${COMP_WORDS[cword_index]}"
        local __val="${__cur##$__ignore_prefix}"

        # Need to look at how _getword works
        if ((cword_index==COMP_CWORD))
        then
            __ip_debug "EXPAND-$_w $*"
            __ip_exp_$_w "$@"
            return 1
        else
            __ip_debug "CHECK-$_w $*"
            __ip_chk_$_w "$@" || return $?
            [[ -n $__set_var ]] && {
                __ip_debug "SETVAR saving $_w '$__val' into $__set_var"
                eval "$__set_var=\"\$__val\""
            }
            return 0
        fi
    }

    COMPREPLY=()

    if ${COMP_VERBOSE:+:} false
    then
        if [[ -t 3 || -w /dev/fd/3 || -w /proc/self/fd/3 ]]
        then
            __ip__cleanup_debug() {
                # If fd#3 is already open, assume it's dedicated for debug output
                # ${COMP_VERBOSE_INIT=$'\e[2J'}          # basic ANSI clear-screen
                printf 'Completion SEEN: %s\n' "${!__ip_seen_*}"
                printf 'Completion END: COMPREPLY=(%s)\e[49;39;0m\n' "${COMPREPLY[*]}"
            } >&3
            echo -n >&3 "${COMP_VERBOSE_INIT:-$'\n################################\n'}"
        else
            # Otherwise, assuming that we're on an Xterm or compatible, display
            # debugging "above" the current line
            : ${COMP_VERBOSE_TINT=$'\e[48;5;210;30m'}  # 256-colour background
            exec 3>&2
            printf >&3 '\e7'
            __ip__cleanup_debug() {
                exec 3>&-
                printf 'Completion SEEN: %s\n' "${!__ip_seen_*}"
                printf 'Completion END: COMPREPLY=(%s)\e[49;39;0m\e8' "${COMPREPLY[*]}"
            } >&3
            echo -n >&3 $'\e[A\e[999I'"${COMP_VERBOSE_TINT}"$'\e[1J\e[5H'
        fi
        echo >&3 "Completion START: ARGS=($*) WORDS=(${COMP_WORDS[*]}) CWORD=$COMP_CWORD KEY=$COMP_KEY" \
                                   "LINE=($COMP_LINE) POINT=$COMP_POINT TYPE=$COMP_TYPE WORDBREAKS=[${COMP_WORDBREAKS/$'\n'/\\n}]"

        __ip__en() { ((cword_index>=COMP_CWORD-2)) ; }
        __ip_debug() { __ip__en && echo >&3 "Completion $*" ; }
        __ip_debug_parsing_state() {
            __ip__en || return 0
            local tag=$1 ; shift
            echo >&3 "Completion STATE $tag word[$cword_index]=$cur state=$STATE expecting=$expecting {$*}"
        }
        __ip_debug_unexpected() { echo >&3 "Completion UNEXPECTED $*" ; }
        __ip_error() { echo >&3 "Completion ERROR $*" ; break 3 ; }
        __ip_unexpected() { echo >&3 "Completion UNEXPECTED $*" ; }
        __ip_warning() { echo >&3 "Completion WARNING $*" ; }
    else
        __ip_debug() { : ; }
        __ip_debug_parsing_state() { : ; }
        __ip_debug_unexpected() { : ; }
        __ip_error() { local t="  $*" ; local l=${#t} ; echo -n >&2 $'\e[1K\e[33m'$t$'\e[39m\e['$l'D' ; break 3 ; }
        __ip_unexpected() { : ; }
        __ip_warning() { : ; }
    fi

    local __perform_expansion=false
    for STATE in START ; do  # {{{
        # singleton "loop", so that "continue 2" works in the next loop
        for ((cword_index=1;cword_index<=COMP_CWORD;cword_index++)) do  # {{{

            ((cword_index==COMP_CWORD)) && __perform_expansion=true
            cur=${COMP_WORDS[cword_index]}

            __ip_debug_parsing_state P1

            [[ -n $want ]] && __ip_match ANY "$want" && break

            want=

            __ip_debug_parsing_state P2

            local _V expecting=${STATE##*/} ; STATE=${STATE%/*}

            local -a _S=()
            local __empty=

            [[ $expecting = =* ]] && want=${expecting#=} expecting=${STATE##*/} STATE=${STATE%/*}

            [[ $expecting = '?'* ]] && __empty=1 expecting=${expecting#'?'}

            __ip_debug_parsing_state P3 ${want:+want=$want} ${__empty:+empty=$__empty}

            case $expecting in  # {{{

            (START)         __ip_match ANY -R -V \
                                          addr address=addr addrlabel link maddr monitor \
                                          mroute neigh ntable route rule tunnel \
                                          xfrm \
                                          -0='-family link' -4='-family inet' -6='-family inet6' \
                                          -B='-family bridge' -D='-family decnet' -I='-family ipx' \
                                          -batch      --batch=-batch           \
                                          -details    --details=-details       \
                                          -family     --family=-family         \
                                          -oneline    --oneline=-oneline       \
                                          -resolve    --resolve=-resolve       \
                                          -statistics --statistics=-statistics \
                                          -timestamp  --timestamp=-timestamp   \
                                          -Version    --Version=-Version
                            __ip_debug_parsing_state P4
                            case $_V in
                            (-family) STATE+=/FAMILY ;;
                            (-0)      save_family=-Flink ;;
                            (-4)      save_family=-Finet ;;
                            (-6)      save_family=-Finet6 ;;
                            (-B)      save_family=-Fbridge ;;
                            (-D)      save_family=-Fdecnet ;;
                            (-I)      save_family=-Fipx ;;

                            (-batch)  STATE+=/BATCHFILE ;;
                            (-*|'')   ;;
                            (*)       STATE=$_V ;;
                            esac
                            ;;

            (BATCHFILE)     save_batchfile=$cur ;;
            (FAMILY)        __ip_match ANY -V dnet inet inet6 ipx link ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            save_family=-F$_V
                            ;;

            (addr)          __ip_match ANY -V add change delete flush list=show monitor replace show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+="+$_V"
                            case $_V in
                            (add|change|delete|replace) STATE+="/=dev/?PREFIX" ;;
                            (flush|list|show) ;;
                            (get) STATE+="/ADDR" ;;
                            esac
                            ;;

            (addr+*)        case ${expecting#*+} in
                            (add|change|replace) __ip_match ANY -R -V preferred_lft valid_lft ;&
                            (flush|list|show)    __ip_match ANY -R -V anycast broadcast deprecated dynamic home label nodad peer \
                                                                      permanent primary scope secondary tentative to ;&
                            (delete)             __ip_match ANY -R -V dev ;;
                            (*) false ;;
                            esac ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (anycast|broadcast)         STATE+=/ADDR     ;;
                            (dev)                       STATE+=/DEVICE   ;;
                            (label)                     STATE+=/LABEL    ;;
                            (preferred_lft|valid_lft)   STATE+=/LIFETIME ;;
                            (peer|to)                   STATE+=/PREFIX   ;;
                            (scope)                     STATE+=/SCOPE    ;;
                            (deprecated|dynamic|home|nodad|permanent|primary|secondary|tentative) ;;
                            esac
                            $__ip_seen_PREFIX || STATE+=/?PREFIX
                            ;;

            (addrlabel)
                            __ip_match ANY -V add del flush  list show=list ?=help help ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4a $_V
                            STATE+=+$_V
                            ;;
            (addrlabel+list) __ip_match_failed ;;
            (addrlabel+*)   __ip_match ANY -V -R prefix dev label ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4b $_V
                            case $_V in
                            (prefix)  STATE+=/PREFIX ;;
                            (dev)     STATE+=/DEVICE ;;
                            (label)   STATE+=/NUMBER ;;
                            esac
                            ;;

            (link)          __ip_match ANY -V add delete list=show ls=show set show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add)                  STATE+=/=link ;;
                            (delete|set|show|list) STATE+=/DEVICE ;;
                            esac
                            ;;

            (link+add)      __ip_match ANY -R -V addr address=addr broadcast link mtu name txqueuelen ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (addr|broadcast)    STATE+=/LLADDR ;;
                            (link)              STATE+=/DEVICE ;;
                            (mtu|txqueuelen)    STATE+=/NUMBER ;;
                            (name)              STATE+=/NAME ;;
                            (type)              STATE+=$_V+type ;;
                            esac
                            ;;

            (link+delete)   __ip_match ANY -R -V addr address=addr broadcast link mtu name txqueuelen ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (link)              STATE+=/DEVICE ;;
                            (type)              STATE+=+$_V+type ;;
                            esac
                            ;;

            (link+set)      __ip_match ANY -V addr address=addr alias allmulticast arp broadcast down dynamic mtu multicast name \
                                              netns promisc trailers txqueuelen up vf ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (addr|broadcast)      STATE+=/LLADDR    ;;
                            (alias)               STATE+=/NAME      ;;
                            (allmulticast|arp|dynamic|multicast|promisc|trailers) STATE+=/ONOFF ;;
                            (mtu)                 STATE+=/NUMBER32  ;;
                            (name)                STATE+=/NAME      ;;
                            (netns)               STATE+=/NUMBER16  ;;
                            (txqueuelen)          STATE+=/NUMBER8   ;;
                            (up|down) ;;
                            (vf)                  STATE+=+vf/NUMBER ;;
                            esac
                            ;;

            (link+set+vf)
                            __ip_match ANY -R -V mac qos rate vlan ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (mac)  STATE+=/LLADDR ;;
                            (qos)  STATE+=/NUMBER8 ;;
                            (rate) STATE+=/RATE ;;
                            (vlan) STATE=link+set+VLAN/=id ;;
                            esac
                            ;;

            (link+set+VLAN) __ip_match ANY -R -V id gvrp loose_binding reorder_hdr ingress-qos-map egress-qos-map ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (id) STATE+=/NUM:1:4095 ;;
                            (gvrp|loose_binding|reorder_hdr) STATE+=/ONOFF ;;
                            (*qos-map) STATE+=/QOSMAP ;;
                            esac
                            ;;

            (link+show|link+list)
                            STATE=FINISH
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            ;;

            (link+*+type)   __ip_match ANY -V can dummy ifb macvlan vcan veth vlan ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (link+*+type+can)
                            __ip_match ANY -R -V berr-reporting bitrate listen-only loopback one-shot phase-seg1 phase-seg2 \
                                                 prop-seg restart restart-ms sample-point sjw tq triple-sampling ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (restart)       ;;
                            (bitrate)       STATE+=/NUM:1:1000000 ;;
                            (restart-ms)    STATE+=/NUMBER ;;
                            (tq)            STATE+=/NUMBER ;;
                            (sample-point)  STATE+=/FLOAT ;;  # SAMPLE-POINT
                            (phase-seg[12]|prop-seg) STATE+=/NUM:1:8 ;;
                            (sjw)           STATE+=/NUM:1:4 ;;
                            (berr-reporting|listen-only|loopback|one-shot|triple-sampling) STATE+=/ONOFF ;;
                            esac
                            ;;
            (link+*+type+dummy)
                            ;;
            (link+*+type+ifb)
                            ;;
            (link+*+type+macvlan)
                            ;;
            (link+*+type+vcan)
                            ;;
            (link+*+type+veth)
                            ;;
            (link+*+type+vlan)
                            ;;

            (maddr)         __ip_match ANY -V show add delete list=show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add|delete) ;;
                            (list|show)  ;;
                            esac
                            ;;

            (maddr+*)       __ip_match ANY -R -V dev ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev) STATE+=/DEVICE ;;
                            esac
                            ;;

            (monitor)       __ip_match ANY -V all addr link maddr mroute neigh ntable route rule tunnel xfrm ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE=FINISH  # no more args
                            ;;

            (mroute)        __ip_match ANY -V list=show show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (show|list) STATE+=+show/PREFIX0 ;;
                            esac
                            ;;
            (mroute+show)   __ip_match ANY -V from iif ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (from)  STATE+=/PREFIX0 ;;
                            (iif)   STATE+=/DEVICE ;;
                            esac
                            ;;

            (neigh)         __ip_match ANY -V add change delete flush list=show replace show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add|change|delete|replace) STATE+=/ADDR ;;
                            (flush|list|show) ;;
                            esac
                            ;;

            (neigh+*)       __ip_match ANY -R -V dev lladdr nud to ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev)       STATE+=/DEVICE ;;
                            (lladdr)    STATE+=/LLADDR ;;
                            (nud)       STATE+=/NUDSTATE ;;
                            (to)        STATE+=/PREFIX0
                            esac
                            ;;

            (ntable)        __ip_match ANY -V change ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (route)         __ip_match ANY -V add append change delete flush get list show=list replace ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (add|append|change|replace) STATE+=+A/=dev/PREFIX0/route+R ;;
                            (delete)                    STATE+=+A/=dev/PREFIX0/route+R ;;
                            (get)                       STATE+=+get/ADDR   ;;
                            (flush|list|show)           STATE+=+L ;;
                            esac
                            ;;

            (route+R)       __ip_match ANY -V blackhole==RTYPE broadcast==RTYPE local==RTYPE multicast==RTYPE nat==RTYPE \
                                              prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE ||
                            __ip_match_empty
                            __ip_debug_parsing_state P4
                            STATE=route+A
                            ;;

            (route+A)       __ip_match ANY -V blackhole==RTYPE broadcast==RTYPE default dev iif local==RTYPE multicast==RTYPE \
                                              nat==RTYPE oif=dev prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE \
                                              via weight ||
                            __ip_match_failed
                            case $_V in
                            (default)       STATE+= ;;
                            (via)           STATE+=/ADDR ;;
                            (dev|iif|oif)   STATE+=/DEVICE ;;
                            (weight)        STATE+=/NUMBER ;;
                            (blackhole)     STATE+=/PREFIX0 ;;
                            (broadcast)     STATE+=/PREFIX0 ;;
                            (local)         STATE+=/PREFIX0 ;;
                            (multicast)     STATE+=/PREFIX0 ;;
                            (nat)           STATE+=/PREFIX0 ;;
                            (prohibit)      STATE+=/PREFIX0 ;;
                            (throw)         STATE+=/PREFIX0 ;;
                            (unicast)       STATE+=/PREFIX0 ;;
                            (unreachable)   STATE+=/PREFIX0 ;;
                            esac
                            ;;

            (route+L)       __ip_match ANY -V exact match proto root scope table type ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (exact)         STATE+=/PREFIX0   ;;
                            (match)         STATE+=/PREFIX0   ;;
                            (proto)         STATE+=/RTPROTO  ;;
                            (root)          STATE+=/PREFIX0   ;;
                            (scope)         STATE+=/SCOPE    ;;
                            (table)         STATE+=/TABLE+   ;;
                            (type)          STATE+=/RTYPE    ;;
                            esac
                            ;;

            (route+get)     __ip_match ANY -V from oif tos ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (from)          STATE+=/=iif/ADDR ;;
                            (dev|iif|oif)   STATE+=/DEVICE    ;;
                            (tos)           STATE+=/TOS       ;;
                            esac
                            ;;

            (route+P)     # ROUTE -> NODE_SPEC -> [RTYPE] PREFIX
                            __ip_match ANY -V advmss cwnd dev equalize initcwnd metric mtu nexthop oif=dev proto realms rto_min \
                                              rtt rttvar scope src ssthresh table tos via weight window ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (advmss|weight)     STATE+=/NUMBER16 ;;
                            (cwnd|initcwnd|mtu) STATE+=/NUMBER32 ;;
                            (dev)               STATE+=/DEVICE   ;;
                            (equalize|onlink|pervasive)         ;;
                            (metric)            STATE+=/NUMBER31S ;;
                            (nexthop)           unset ${!__ip_seen_*} ;;  # reset the "already seen" list
                            (proto)             STATE+=/RTPROTO  ;;
                            (realms)            STATE+=/REALM    ;;  # TODO maybe this should be REALMPAIR?
                            (rto_min|rtt|rttvar) STATE+=/TIME    ;;
                            (scope)             STATE+=/SCOPE    ;;
                            (src|via)           STATE+=/ADDR     ;;
                            (ssthresh)          STATE+=/NUMBER   ;;
                            (table)             STATE+=/TABLE    ;;
                            (tos)               STATE+=/TOS      ;;
                            (window)            STATE+=/NUMBER8  ;;
                            esac
                            ;;

            (rule)          __ip_match ANY -V add delete flush list show=list ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (rule+list)     __ip_match ANY '# no more args allowed' ' ' ;;  # no args allowed

            (rule+*)        __ip_match ANY -R -V dev from fwmark goto iif=dev lookup not pref prio prohibit realms reject table \
                                                 to tos unreachable ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev)           STATE+=/DEVICE   ;;
                            (from|to)       STATE+=/PREFIX0  ;;
                            (fwmark)        STATE+=/FWMARK+MASK ;;
                            (goto|pref|prio) STATE+=/NUMBER  ;;
                            (lookup|table)  STATE+=/TABLE    ;;
                            (not|prohibit|reject|unreachable) ;;
                            (realms)        STATE+=/REALMPAIR ;;
                            (tos)           STATE+=/TOS      ;;
                            esac
                            ;;

            (tunnel)        __ip_match ANY -V 6rd add change del delete=del list=show prl show ||
                            __ip_match_failed
                            STATE+=+$_V/=name
                            ;;

            (tunnel+*)      case $expecting in
                            (*+6rd) __ip_match ANY -R -V 6rd-prefix 6rd-relay_prefix 6rd-reset ;;
                            (*+prl) __ip_match ANY -R -V prl-default prl-delete prl-nodefault ;;
                            (*) false ;;
                            esac ||
                            __ip_match ANY -R -V dev icsum ikey iseq local mode nopmtudisc==pmtudisc ocsum oif=dev okey oseq \
                                                 pmtudisc remote tos ttl ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (icsum|iseq|ocsum|oseq|nopmtudisc|pmtudisc) ;;
                            (6rd-reset) ;;
                            (6rd-*|local|prl-*|remote)
                                            STATE+=/ADDR    ;;
                            (dev|oif)       STATE+=/DEVICE  ;;
                            (ikey|okey)     STATE+=/KEY     ;;
                            (mode)          STATE+=/TMODE   ;;
                            (name)          STATE+=/NAME    ;;
                            (tos)           STATE+=/TOS     ;;
                            (ttl)           STATE+=/TTL     ;;
                            esac
                            ;;

            (KEY)           __ip_match_addr -Finet || __ip_match NUM || __ip_match_failed ;;
            (TOS)           __ip_match NUM -V                   || __ip_match ANY inherit || __ip_match_failed ;;
            (TTL)           __ip_match NUM -V --min=1 --max=255 || __ip_match ANY inherit || __ip_match_failed ;;

            (TMODE)         __ip_match ANY ipip gre sit || __ip_match_failed ;;

            (xfrm)          __ip_match ANY -V policy state monitor || __ip_match_failed
                            STATE+=+$_V
                            ;;

            (xfrm+*)        __ip_match_failed
                            ;; # TODO

            (NAME)          __ip_match ANY "$cur " "$cur..." || __ip_match_failed ; __ip_seen_NAME=true ;;
            (ADDR)          __ip_match_addr $save_family     || __ip_match_failed ;;
            (MADDR)         __ip_match_addr $save_family -m  || __ip_match_failed ;;
            (LLADDR)        __ip_match_addr -Flink           || __ip_match_failed ;;
            (PREFIX0)       __ip_match_addr $save_family -pd || __ip_match_failed ; __ip_seen_PREFIX=true ;;
            (PREFIX)        __ip_match_addr $save_family -p  || __ip_match_failed ; __ip_seen_PREFIX=true ;;

            (DEVICE)        __ip_match ANY -Vsave_device $( ip -o link list | sed -e "s/^[0-9]*: //; s/: .*//; /^wmaster/d" ) ||
                            __ip_match_failed ;;
            (FWMARK+MASK)   case $cur in
                            (*/*/*) false ;;
                            (*)    __ip_match NUM -I'*/' --32bit ;;
                            esac ||
                            __ip_match_failed ;;
            (LIFETIME)      __ip_match ANY forever ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;

            (NUDSTATE)      __ip_match ANY noarp permanent reachable stale || __ip_match_failed ;;

            (NUM:*:*)       max_num=${expecting#NUM:} ; min_num=${max_num%:*} max_num=${max_num#*:}
                            __ip_match NUM --min=$min_num --max=$max_num || __ip_match_failed ;;
            (NUM:*)         __ip_match NUM --max=${expecting##*:}        || __ip_match_failed ;;
            (NUMBER)        __ip_match NUM                               || __ip_match_failed ;;
            (NUMBER8)       __ip_match NUM --8bit                        || __ip_match_failed ;;
            (NUMBER16)      __ip_match NUM --16bit                       || __ip_match_failed ;;
            (NUMBER32)      __ip_match NUM --32bit                       || __ip_match_failed ;;
            (NUMBER31S)     __ip_match NUM --signed32bit                 || __ip_match_failed ;;
            (ONOFF)         __ip_match ANY on off                               || __ip_match_failed ;;
            (QOSMAP)        case $cur in
                            (*[^0-9:]*|*:*:*) false ;;
                            (*)   __ip_match NUM -I'*:' ;;
                            esac || __ip_match_failed ;;
            (REALMPAIR)     case $cur in
                            (*/*/*) false ;;
                            (*)     __ip_match NUM -I'*/' --8bit ||
                                    __ip_match ANY -C${cur#*/} $( __ip_slurp /etc/iproute2/rt_realms ) ;;
                            esac ||
                            __ip_match_failed ;;
            (REALM)         __ip_match NUM --8bit ||
                            __ip_match ANY $( __ip_slurp /etc/iproute2/rt_realms ) ||
                            __ip_match_failed ;;
            (SCOPE)         __ip_match NUM --8bit ||
                            __ip_match ANY $( __ip_slurp /etc/iproute2/rt_scopes ) ||
                            __ip_match_failed ;;
            (LABEL)         [[ $save_device ]] && __ip_match ANY $save_device: $save_device:... || true ;;
            (TABLE)         __ip_match NUM --8bit ||
                            __ip_match ANY default local main $( __ip_slurp /etc/iproute2/rt_tables ) ||
                            __ip_match_failed ;;
            (TABLE+)        __ip_match NUM --max=255 --min=-2 ||
                            __ip_match ANY all default local main $( __ip_slurp /etc/iproute2/rt_tables ) ||
                            __ip_match_failed ;;
            (RTYPE)         __ip_match ANY -R blackhole==RTYPE broadcast==RTYPE local==RTYPE multicast==RTYPE nat==RTYPE \
                                              prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE ||
                            __ip_match_failed ;;
            (RTPROTO)       __ip_match ANY -R boot==RTPROTO kernel==RTPROTO static==RTPROTO ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;
            (TOS)           __ip_match ANY inherit ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;

            (*)             __ip_error "Lost sync? STATE=$STATE expect=$expecting cur=$cur" ;;

            esac  # }}}

            __ip_debug_parsing_state P5

        done  # }}}

        __ip_debug "COMPREPLY=[${COMPREPLY[*]}] (after compgen)"

        ((${#COMPREPLY[@]} == 0)) && __ip_warning "No matches for '$cur'"

        # completion treats some punctuation as if they were word-separators, and appends to current word rather than replacing it
        if [[ -n "$COMP_WORDBREAKS" && $cur = *[$COMP_WORDBREAKS]* ]]
        then
            local rword_index
            cur="${cur%"${cur##*[$COMP_WORDBREAKS]}"}"
            for ((rword_index=0 ; rword_index<${#COMPREPLY[@]} ; rword_index++ )) do
                COMPREPLY[rword_index]="${COMPREPLY[rword_index]#"$cur"}"
            done
        fi

        __ip__cleanup
        return 0
    done  # }}} end singleton loop
    COMPREPLY=()
    __ip_debug_parsing_state '***ABORT***'
    #__ip_unexpected "Lost sync? STATE=$STATE expect=$expecting cur=$__cur"

    [[ $COMP_TYPE = best ]] && COMP_TYPE=9

    __ip__cleanup
    return 1
}
complete -F _ip -o nospace ip
