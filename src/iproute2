#! library/module/for/bash
#
# ip (iproute2) command-line completion for Bash.
#
# Written by Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Released at LCA2010, 19 January 2010.
# Updated to use proper parser state-stack April 2012.
#
# You may copy and use this program under the terms of version three of the Gnu
# Public Licence, or any later version as published by the Free Software
# Foundation.
#
# Set COMP_VERBOSE to any non-null value to enable debugging output; unset it
# to disable.
#

[[ $(type -t have) != function ]] || have ip || return

#
# If the function "cluck" is defined, use it; otherwise display the given
# message, with a stack trace using the "caller" built-in (if available).
#
__ip_cluck() {
    ${COMP_VERBOSE:+:} false || return
    if [[ $( type -t cluck ) = function ]]
    then
        (cluck "$@" >&3 2>&3)
    elif [[ $( type -t caller ) = builtin ]]
    then
        echo >&3 "$*"
        local l d
        for ((l=1;l<20;l++)) do
            d=$(caller $l) && [[ -n $d ]] || break
            echo >&3 "    $d"
        done
        echo >&3
    else
        echo >&3 "$*"
    fi
}

#
# Read in the contents of a file, minus comments
#
__ip_slurp() {
    local l
    while read l
    do  l=${l//$'\t'/' '}          # squash tabs and spaces
        l=${l//'                '/' '} # ''
        l=${l//'        '/' '}     # ''
        l=${l//'    '/' '}         # ''
        l=${l//'  '/' '}           # ''
        l=${l%%'#'*}               # strip comments
        l=${l#"${l%%[^0-9]*} "}    # strip leading word comprised entirely of digits
        [[ -n $l ]] || continue
        echo "$l"
    done <$1
    return
}

#
# The __ip_match* family of functions attempt to match various
#
# They rely on three global variables: COMP_WORDS[], COMP_CWORD & cword_index.
# (When cword_index equals COMP_CWORD, this is the "focal" word, so generate a
# full list of possible matches; otherwise we're just parsing before the focal
# word, so just do basic checking, and stash the value if requested.)
#
# The only time they return "true" is when they have *the only* possible match,
# and that generally means only for non-focus words.
#
# __ip_match NUM [--[signed-]N-bit] [--max=N] [--min=N]
#                   [-A | -Bauto | -BN]
#                   [-Iprefix] [-Ssuffix] [-V[varname]]

__ip_chk_NUM() {
    __ip_debug "CHECKNUM $*"
    if
        [[ $__val = ?*     && $__val != *[^0-9]*      ]] ||
        [[ $__radix = auto && $__val = 0x?* && $__val != 0x*[^0-9a-f]* ]] ||
        [[ $__radix = 16   && $__val != *[^0-9a-f]*   ]]
    then
        (( __val += 0 ))
        return 0
    else
        (( __val = 0 ))
        return 1
    fi
}

__ip_exp_NUM() {
    local -a __digits=( 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z @ _ )
    __ip_debug "MATCHNUM min=$__min max=$__max radix=$__radix prefix=$__ignore_prefix suffix=$__suffix $*"
    if [[ ${__radix:?'Radix not set!'} = auto ]]
    then
        case $__val in
        (0x*) __radix=16 ;;
        (0*)  __radix=8 ;;
        (*)   __radix=10 ;;
        esac
    fi

    __val=${__val#0x} __val=${__val#${__val%%[^0]*}}
    if (( ${#__neg} & 1 ))
    then
        case $__min:$__max in
        (:?*)   ((__min=-__max)) ; __max= ;;
        (*?:)   ((__max=-__min)) ; __min= ;;
        (*?:?*) eval "(( __min=-($__max), __min=-($__min) )) " ;;
        esac
    fi

    # No non-digits allowed
    # Check that it contains no disallowed digits
    if  [[ $__val = *[^${__digits[*]:0:__radix}]* || $__val = *' '* ]]
    then
        __ip_unexpected "MATCHNUM $__val not suitable for radix $__radix"
        return 1
    fi

    # TODO INSERT NEW ALGORITHM HERE

    local __i
    (( __i = $__radix#$__val ))

    (( __min <= __i && __i <= __max )) && COMPREPLY=( "${COMPREPLY[@]}" "$__cur$__suffix" )

    local __min_digit __max_digit

    (( __offset = __i * __radix ))
    while
        (( __min_digit = (${#__min}==0 || __min < __offset ? 0 : __min - __offset),
           __max_digit = (${#__max}==0 || __max >= __offset+__radix ? __radix-1 : __max - __offset ) ))
        (( __min_digit >= __radix ))
    do
        __ip_debug "MATCHNUM: $__cur->$__val->$__i radix=$__radix offset=$__offset (min=$__min max=$__max) -> (min_digit=$__min_digit max_digit=$__max_digit) RETRY"
        (( __min/=__radix, __max/=__radix ))
    done
    __ip_debug "MATCHNUM: $__cur->$__val->$__i radix=$__radix offset=$__offset (min=$__min max=$__max) -> (min_digit=$__min_digit max_digit=$__max_digit)"

    for ((__i=__min_digit;__i<=__max_digit;++__i)) do
        COMPREPLY=( "${COMPREPLY[@]}" "${__cur}${__digits[__i]}" )
    done
}

#
# __ip_match ANY [-R[KEY]] [-S[SUFFIX]] [-V[VARNAME]] [MATCH-LIST...]
#
# The MATCH-LIST elements are of the form [MATCH=]TOKEN or MATCH=[TOKEN]=GROUP.
# The TOKEN is included in COMPREPLY (which means it may replace a partially
# typed ALIAS); GROUP is used to set the -V parameter (if set).
#

__ip_chk_ANY() {
    #__ip_debug "CHECK seen=$__skip_seen seen_pref=$__seen_pref set_var=$__set_var val=$__val WORDS=($*)"
    for _p do
        _t="${_p%%=*}"
        [[ $_t = "$__val"* ]] || continue
        _p="${_p#*=}"
        $__skip_seen && {
            _q="${_p#*=}"
            _q="$__seen_pref${_q//[^_0-9a-zA-Z]/__}"
            #__ip_debug "Remembering that $_p has been seen (setting $_q=true)"
            eval $_q=true
        }
        _p="${_p%%=*}"
        _p="${_p:-$_t}"
        __val="$_p"
        return 0
    done
    return 1
}

__ip_exp_ANY() {
    #__ip_debug "MATCH seen=$__skip_seen seen_pref=$__seen_pref set_var=$__set_var val=$__val WORDS=($*)"
    for _p do
        _t="${_p%%=*}"
        [[ $_t = "$__val"* ]] || continue
        _p="${_p#*=}"
        $__skip_seen && {
            _q="${_p#*=}"
            _q="$__seen_pref${_q//[^_0-9a-zA-Z]/__}"
            eval \${$_q:+:} false && continue
        }
        _p="${_p%%=*}"
        _p="${_p:-$_t}"
        COMPREPLY=( "${COMPREPLY[@]}" "$_p$__suffix" )
        #[[ $COMP_TYPE = best ]] && return 0  # unfortunately this doesn't work; after the first tab-key, the shell will always show a list, even if it (now) has only one member
    done
}

__ip_chk_ADDR() {
    $accept_prefix && [[ $__val = */* && $__val != */*[^0-9]* ]] && __val=${__val%/*}
    { $accept_default && [[ default = "$__val"* ]] ; } ||
    { $accept_ipv6   && [[ $__val = *::* || $__val = *:*:*:*:*:*:*:* || $__val = *:*:*:*:*:*:*.*.*.* ]] ; } ||
    { $accept_ipv4   && [[ $__val = *.*.*.* && $__val != *:* ]] ; } ||
    { $accept_link   && [[ $__val = ??:??:??:??:??:?? ]] ; } || {
        __ip_warning "Cannot match '$__val' as requested type of address"
        return 1
    }
}

__ip_exp_ADDR() {
    # Accept "default" keyword, if appropriate
    if $accept_default
    then
        __ip_match ANY default
        return
    fi

    if $accept_prefix
    then
        __ip_debug "Looking for prefix"
        case $__val in
        (*:*/*) __ip_match NUM -I'*/' -B10 --min=1 --max=128 ; return ;;
        (*/*)   __ip_match NUM -I'*/' -B10 --min=1 --max=32  ; return ;;
        (*.*.*.*?|*::|*::*:*?|*:*:*:*:*:*:*:*) __ip_match CUR -S/ ;;
        esac
    else
        case $__val in
        (*/*)   __ip_warning "Prefix not allowed" ;; # return ;;
        esac
    fi

    if $accept_link
    then
        __ip_debug "Looking for link-layer MAC (Ethernet) address"
        case :$__val in
        (*::*|*:?:*|*[^:][^:][^:]*|*[^0-9a-f:]*) ;;
        (:??:??:??:??:??:??) __ip_match CUR ;;
        (*:??)              __ip_match CUR -S: ;;
        (*)                 __ip_match NUM -I'*:' -B16 --8bit ;;
        esac
    fi

    if $accept_ipv6
    then
        __ip_debug "Looking for IPv6 address"

        __ip_match ANY -S'' fe80:: fc00:: :: ::1

        # one 16-bit block
        case $__val in
        (*:*:*:*:*:*:*:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]) __ip_match CUR ;;                      # whole last block?
        (*:[0-9a-f][0-9a-f][0-9a-f][0-9a-f]) __ip_match CUR    -S: ;;                           # whole middle block?
        (*:*:*:*:*:*:*:*)   __ip_match NUM -I'*:' -B16 --16bit     ;;                           # last block?
        (*:*)               __ip_match NUM -I'*:' -B16 --16bit -S: ;;                           # middle block
        (*)                 __ip_match NUM        -B16 --16bit -S: --min=0x2000 --max=0x3fff ;; # first block?
        esac

        # embedded IPv4?
        case $__val in
        (::*.*.*.*) __ip_match NUM -I'*.'    -A --8bit ;;
        (::*:*) ;;
        (::*)       __ip_match NUM -I'*[:.]' -A --8bit -S. ;;
        esac

        # complete as-is?
        [[ ( $__val = *:*:*:*:*:*:*:*? || $__val = *::*? ) && $__val != *. ]] && __ip_match CUR -S' '

    fi

    if $accept_ipv4
    then
        __ip_debug "Looking for IPv4 address"
        case $__val in
        (*:*)       ;;
        (*.*.*.*)   __ip_match NUM -I'*.' -A --8bit ;;
        (*)         __ip_match NUM -I'*.' -A --8bit -S. ;;
        esac
    fi
}

__ip_match_addr() {
  # __ip_match ADDR "$@"
  # return $?
    local accept_link= accept_ipv4= accept_ipv6= \
          accept_prefix=false accept_default=false \
          require_multicast=false require_unicast=false
    local __set_var=
    local __skip_seen=false _R= __seen_pref= _p

    while [[ $1 = -* ]]
    do
        case $1 in
        ( -Fdual )          accept_ipv4=true accept_ipv6=true ;;
        ( -Finet  )         accept_ipv4=true ;;
        ( -Finet6  )        accept_ipv6=true ;;
        ( -Flink  )         accept_link=true ;;
      # ( -F*)              __ip_unexpected "Family '${1#-?}' is not supported" ; return 0 ;;
        ( -m )              require_multicast=true ;;
        ( -p )              accept_prefix=true ;;
        ( -pd )             accept_prefix=true accept_default=true ;;
        ( -R* )             __skip_seen=true _R=$1 _p=${1#-?} __seen_pref=__ip_seen_${_p:-${expecting//[^_0-9a-zA-Z]/__}}___ ;;
        ( -V* )             _p=${1#-?} __set_var=${_p:-_V} ;;
        (*)                 __ip_error "Invalid option '$1' to __ip_match_addr" ; break 3 ;;
        esac
        shift
    done
    : ${accept_link:=false} ${accept_ipv4=false} ${accept_ipv6=false}

    local __cur="${COMP_WORDS[cword_index]}"
    local __val="${__cur##$__ignore_prefix}"

    __ip_debug "Completing address starting with '$__cur'; will accept" $( for w in ipv4 ipv6 prefix link ; do eval \$accept_$w && echo $w ; done )

    # Reject impossible things...
    if [[ ( $__cur = *[^0-9a-f:./]* && default != "$__cur"* ) ||
          $__cur = *:*:*:*:*:*:*:*:* ||
          $__cur = *:::* ||
          $__cur = *::*::* ||
          $__cur = *.*.*.*.* ||
          $__cur = *.*[^0-9./]* ||
          $__cur = */*[^0-9]* ]]
    then
        __ip_warning "Cannot match '$__cur' as any type of address"
        return 1
    fi

    if ((cword_index==COMP_CWORD))
    then
        __ip_debug "EXPAND-ADDR $*"
        __ip_exp_ADDR "$@"
        return 1
    else
        __ip_debug "CHECK-ADDR $*"
        __ip_chk_ADDR "$@" || return $?
        [[ -n $__set_var ]] && {
            __ip_debug "SETVAR saving ADDR '$__cur' into $__set_var"
            eval "$__set_var=\"\$__cur\""
        }
        return 0
    fi
}

#
# __ip_match_empty and __ip_match_failed may be called when other matching
# functions return non-zero; they take some rather peculiar action as a result:
#
# * 'break' will cause the match loop will cease and possible completions
#   computed so far (COMPREPLY) will be used
# * 'break 2' will cause all processing will immediately stop, and no
#   completions will be available
# * 'decrement cword_index and continue' will cause the match loop will start
#   over, testing the same word against the previous non-terminal, adding to
#   the possible completions computed so far (COMPREPLY).
#

__ip_match_empty()  {
    __ip_debug_parsing_state "MATCH-EMPTY(1) $expecting"
    ((--cword_index))
    continue
}

__ip_match_failed() {
    if ((__empty))
    then
        # treat same as __ip_match_empty
        __ip_debug_parsing_state "MATCH-EMPTY(2) $expecting"
        ((--cword_index))
        continue
    elif ((cword_index==COMP_CWORD))
    then
        __ip_debug_parsing_state "MATCH-LAST $expecting"
        break
    fi

    __ip_debug_parsing_state "MATCH-FAILED $expecting"
    __ip_cluck -x -s -S0 "MATCH-FAILED $expecting BACKTRACE"
    break 2
}

__ip_chk_CUR() {
    true
}

__ip_exp_CUR() {
    COMPREPLY=( "${COMPREPLY[@]}" "$__cur$__suffix" )
}

__ip_match() {
    local _w="$1" ; shift

    local __skip_seen=false _R= __seen_pref=
    local __set_var=
    local __max= __min=0 __radix=auto
    local __ignore_prefix= __suffix=' '
    local _p _q _t

    while [[ $1 = -* ]]
    do
        case $1 in
        ( --[0-9]*bit )     (( _p=${1//[^0-9]/}, __min=0, __max=(1<<_p)-1)) ;;
        ( --max*=* )        __max=${1#--*=} ;;
        ( --min*=* )        __min=${1#--*=} ;;
        ( --s*[0-9]*bit )   (( _p=${1//[^0-9]/}-1, __min=-1<<_p, __max=(1<<_p)-1)) ;;
        ( -A )              __radix=auto ;;
        ( -B?* )            __radix=${1#-?} ;;
        ( -I* )             __ignore_prefix=${1#-?} ;;
        ( -R* )             __skip_seen=true _R=$1 _p=${1#-?} __seen_pref=__ip_seen_${_p:-${expecting//[^_0-9a-zA-Z]/__}}___ ;;
        ( -S* )             __suffix=${1#-?} ;;
        ( -V* )             _p=${1#-?} __set_var=${_p:-_V} ;;
        (*)                 __ip_error "Invalid option '$1' to __ip_match[$_w]" ;;
        esac
        shift
    done

    local __cur="${COMP_WORDS[cword_index]}"
    local __val="${__cur##$__ignore_prefix}"

    # Need to look at how _getword works
    if ((cword_index==COMP_CWORD))
    then
        __ip_debug "EXPAND-$_w $*"
        __ip_exp_$_w "$@"
        return 1
    else
        __ip_debug "CHECK-$_w $*"
        __ip_chk_$_w "$@" || return $? 
        [[ -n $__set_var ]] && {
            __ip_debug "SETVAR saving $_w '$__val' into $__set_var"
            eval "$__set_var=\"\$__val\""
        }
        return 0
    fi
}

_ip() {
    case $COMP_TYPE in
    (63) ((++__ip_comp_count >= 3)) && COMP_TYPE=best ;;
    (9)  ((__ip_comp_count=1)) ;;
    (*)  ((__ip_comp_count=0)) ;;
    esac
    COMP_WORDBREAKS="${COMP_WORDBREAKS//:/}"

    # "seen" is stack of partial states, as a string separated by slashes, shallowest-to-deepest
    local STATE=
    local cur="(start-of-line)"
    local cword_index=0
    local save_device=
    local save_family='-Fdual'
    local want=
    local max_num= min_num=
    local expecting=
    local __ip_seen_PREFIX=false

    COMPREPLY=()

    # Too hard to localize everything, so clean up from last time
    unset ${!__ip_seen_*}

    if ${COMP_VERBOSE:+:} false
    then
        if [[ -t 3 || -w /dev/fd/3 || -w /proc/self/fd/3 ]]
        then
            # If fd#3 is already open, assume it's dedicated for debug output
            # ${COMP_VERBOSE_INIT=$'\e[2J'}          # basic ANSI clear-screen
            trap "
                    trap RETURN ;
                    echo >&3 \"Completion SEEN: \${!__ip_seen_*}\" ;
                    echo >&3 \"Completion END: COMPREPLY=(\${COMPREPLY[*]})\"\$'\\e[49;39;0m\n' ;
                " RETURN
            echo -n >&3 "${COMP_VERBOSE_INIT:-$'\n################################\n'}"
        else
            # Otherwise, assuming that we're on an Xterm or compatible, display
            # debugging "above" the current line
            : ${COMP_VERBOSE_TINT=$'\e[48;5;210;30m'}  # 256-colour background
            exec 3>&2
            echo -n >&3 $'\e7'
            trap "
                    trap RETURN ;
                    echo >&3 \"Completion SEEN: \${!__ip_seen_*}\" ;
                    echo -n >&3 \"Completion END: COMPREPLY=('\${COMPREPLY[*]}')\"\$'\\e[49;39;0m' ;
                    echo -n >&3 \$'\\e8' ;
                    exec 3>&- ;
                " RETURN
            echo -n >&3 $'\e[A\e[999I'"${COMP_VERBOSE_TINT}"$'\e[1J\e[5H'
        fi
        echo >&3 "Completion START: ARGS=($*) WORDS=(${COMP_WORDS[*]}) CWORD=$COMP_CWORD KEY=$COMP_KEY LINE=($COMP_LINE) POINT=$COMP_POINT TYPE=$COMP_TYPE WORDBREAKS=[${COMP_WORDBREAKS/$'\n'/\\n}]"

        __ip__en() { ((cword_index>=COMP_CWORD-2)) ; }
        __ip_debug() { __ip__en && echo >&3 "Completion $*" ; }
        __ip_debug_parsing_state() { __ip__en || return 0 ; local tag=$1 ; shift ; echo >&3 "Completion STATE $tag word[$cword_index]=$cur state=$STATE expecting=$expecting {$*}" ; }
        __ip_debug_unexpected() { echo >&3 "Completion UNEXPECTED $*" ; }
        __ip_error() { echo >&3 "Completion ERROR $*" ; break 3 ; }
        __ip_unexpected() { echo >&3 "Completion UNEXPECTED $*" ; }
        __ip_warning() { echo >&3 "Completion WARNING $*" ; }
    else
        trap ' unset ${!__ip_seen_*} ' RETURN
        __ip_debug() { : ; }
        __ip_debug_parsing_state() { : ; }
        __ip_debug_unexpected() { : ; }
        __ip_error() { local t="  $*" ; local l=${#t} ; echo -n >&2 $'\e[1K\e[33m'$t$'\e[39m\e['$l'D' ; break 3 ; }
        __ip_unexpected() { : ; }
        __ip_warning() { : ; }
    fi

    local __perform_expansion=false
    for STATE in START ; do  # {{{
        # dummy loop
        for ((cword_index=1;cword_index<=COMP_CWORD;cword_index++)) do  # {{{

            ((cword_index==COMP_CWORD)) && __perform_expansion=true
            cur=${COMP_WORDS[cword_index]}

            __ip_debug_parsing_state P1

            [[ -n $want ]] && __ip_match ANY "$want" && break

            want=

            __ip_debug_parsing_state P2

            local _V expecting=${STATE##*/} ; STATE=${STATE%/*}

            local -a _S=()
            local __empty=

            [[ $expecting = =* ]] && want=${expecting#=} expecting=${STATE##*/} STATE=${STATE%/*}

            [[ $expecting = '?'* ]] && __empty=1 expecting=${expecting#'?'}

            __ip_debug_parsing_state P3 ${want:+want=$want} ${__empty:+empty=$__empty}

            case $expecting in  # {{{

            (START)         __ip_match ANY -R -V \
                                          addr address=addr addrlabel link maddr monitor \
                                          mroute neigh ntable route rule tunnel \
                                          xfrm \
                                          -0='-family link' -4='-family inet' -6='-family inet6' \
                                          -batch      --batch=-batch           \
                                          -details    --details=-details       \
                                          -family     --family=-family         \
                                          -oneline    --oneline=-oneline       \
                                          -resolve    --resolve=-resolve       \
                                          -statistics --statistics=-statistics \
                                          -timestamp  --timestamp=-timestamp   \
                                          -Version    --Version=-Version       
                            __ip_debug_parsing_state P4
                            case $_V in
                            (-*family) STATE+=/FAMILY ;;
                            (-0)      save_family=-Flink __ip_seen___family=true ;;
                            (-4)      save_family=-Finet __ip_seen___family=true ;;
                            (-6)      save_family=-Finet6 __ip_seen___family=true ;;
                            (-*batch) STATE+=/BATCHFILE ;;
                            (-*|'') ;;
                            (*)       STATE=$_V ;;
                            esac
                            ;;

            (BATCHFILE)     save_batchfile=$cur ;;
            (FAMILY)        __ip_match ANY -V dnet inet inet6 ipx link ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            save_family=-F$_V
                            ;;

            (addr)          __ip_match ANY -V add change delete flush list=show monitor replace show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+="+$_V"
                            case $_V in
                            (add|change|delete|replace) STATE+="/=dev/?PREFIX" ;;
                            (flush|list|show) ;;
                            (get) STATE+="/ADDR" ;;
                            esac
                            ;;

            (addr+*)        case ${expecting#*+} in
                            (flush|list|show)    __ip_match ANY -R -V anycast broadcast deprecated dev dynamic home label nodad peer permanent               primary scope secondary tentative to           ;;
                            (add|change|replace) __ip_match ANY -R -V anycast broadcast deprecated dev dynamic home label nodad peer permanent preferred_lft primary scope secondary tentative to valid_lft ;;
                            (delete)             __ip_match ANY -R -V                              dev ;;
                            (*) false ;;
                            esac ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (anycast|broadcast)         STATE+=/ADDR     ;;
                            (dev)                       STATE+=/DEVICE   ;;
                            (label)                     STATE+=/LABEL    ;;
                            (preferred_lft|valid_lft)   STATE+=/LIFETIME ;;
                            (peer|to)                   STATE+=/PREFIX   ;;
                            (scope)                     STATE+=/SCOPE    ;;
                            (deprecated|dynamic|home|nodad|permanent|primary|secondary|tentative) ;;
                            esac
                            $__ip_seen_PREFIX || STATE+=/?PREFIX
                            ;;

            (addrlabel)     
                            __ip_match ANY -V add del flush  list show=list ?=help help ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4a $_V
                            STATE+=+$_V
                            ;;
            (addrlabel+list) __ip_match_failed ;;
            (addrlabel+*)   __ip_match ANY -V -R prefix dev label ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4b $_V
                            case $_V in
                            (prefix)  STATE+=/PREFIX ;;
                            (dev)     STATE+=/DEVICE ;;
                            (label)   STATE+=/NUMBER ;;
                            esac
                            ;;

            (link)          __ip_match ANY -V add delete list=show ls=show set show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add)                  STATE+=/=link ;;
                            (delete|set|show|list) STATE+=/DEVICE ;;
                            esac
                            ;;

            (link+add)      __ip_match ANY -R -V addr address=addr broadcast link mtu name txqueuelen ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (addr|broadcast)    STATE+=/LLADDR ;;
                            (link)              STATE+=/DEVICE ;;
                            (mtu|txqueuelen)    STATE+=/NUMBER ;;
                            (name)              STATE+=/NAME ;;
                            (type)              STATE+=$_V+type ;;
                            esac
                            ;;

            (link+delete)   __ip_match ANY -R -V addr address=addr broadcast link mtu name txqueuelen ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (link)              STATE+=/DEVICE ;;
                            (type)              STATE+=+$_V+type ;;
                            esac
                            ;;

            (link+set)      __ip_match ANY -V addr address=addr alias allmulticast arp broadcast down dynamic mtu multicast name netns promisc trailers txqueuelen up vf ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (addr|broadcast)      STATE+=/LLADDR    ;;
                            (alias)               STATE+=/NAME      ;;
                            (allmulticast|arp|dynamic|multicast|promisc|trailers) STATE+=/ONOFF ;;
                            (mtu)                 STATE+=/NUMBER32  ;;
                            (name)                STATE+=/NAME      ;;
                            (netns)               STATE+=/NUMBER16  ;;
                            (txqueuelen)          STATE+=/NUMBER8   ;;
                            (up|down) ;;
                            (vf)                  STATE+=+vf/NUMBER ;;
                            esac
                            ;;

            (link+set+vf)
                            __ip_match ANY -R -V mac qos rate vlan ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (mac)  STATE+=/LLADDR ;;
                            (qos)  STATE+=/NUMBER8 ;;
                            (rate) STATE+=/RATE ;;
                            (vlan) STATE=link+set+VLAN/=id ;;
                            esac
                            ;;

            (link+set+VLAN) __ip_match ANY -R -V id gvrp loose_binding reorder_hdr ingress-qos-map egress-qos-map ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (id) STATE+=/NUM:1:4095 ;;
                            (gvrp|loose_binding|reorder_hdr) STATE+=/ONOFF ;;
                            (*qos-map) STATE+=/QOSMAP ;;
                            esac
                            ;;

            (link+show|link+list)
                            STATE=FINISH
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            ;;

            (link+*+type)   __ip_match ANY -V can dummy ifb macvlan vcan veth vlan ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (link+*+type+can)
                            __ip_match ANY -R -V berr-reporting bitrate listen-only loopback one-shot phase-seg1 phase-seg2 prop-seg restart restart-ms sample-point sjw tq triple-sampling ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (restart)       ;;
                            (bitrate)       STATE+=/NUM:1:1000000 ;;
                            (restart-ms)    STATE+=/NUMBER ;;
                            (tq)            STATE+=/NUMBER ;;
                            (sample-point)  STATE+=/FLOAT ;;  # SAMPLE-POINT
                            (phase-seg[12]|prop-seg) STATE+=/NUM:1:8 ;;
                            (sjw)           STATE+=/NUM:1:4 ;;
                            (berr-reporting|listen-only|loopback|one-shot|triple-sampling) STATE+=/ONOFF ;;
                            esac
                            ;;
            (link+*+type+dummy)
                            ;;
            (link+*+type+ifb)
                            ;;
            (link+*+type+macvlan)
                            ;;
            (link+*+type+vcan)
                            ;;
            (link+*+type+veth)
                            ;;
            (link+*+type+vlan)
                            ;;

            (maddr)         __ip_match ANY -V show add delete list=show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add|delete) ;;
                            (list|show)  ;;
                            esac
                            ;;

            (maddr+*)       __ip_match ANY -R -V dev ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev) STATE+=/DEVICE ;;
                            esac
                            ;;

            (monitor)       __ip_match ANY -V all addr link maddr mroute neigh ntable route rule tunnel xfrm ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE=FINISH  # no more args
                            ;;

            (mroute)        __ip_match ANY -V list=show show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (show|list) STATE+=+show/PREFIX0 ;;
                            esac
                            ;;
            (mroute+show)   __ip_match ANY -V from iif ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (from)  STATE+=/PREFIX0 ;;
                            (iif)   STATE+=/DEVICE ;;
                            esac
                            ;;

            (neigh)         __ip_match ANY -V add change delete flush list=show replace show ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            case $_V in
                            (add|change|delete|replace) STATE+=/ADDR ;;
                            (flush|list|show) ;;
                            esac
                            ;;

            (neigh+*)       __ip_match ANY -R -V dev lladdr nud to ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev)       STATE+=/DEVICE ;;
                            (lladdr)    STATE+=/LLADDR ;;
                            (nud)       STATE+=/NUDSTATE ;;
                            (to)        STATE+=/PREFIX0
                            esac
                            ;;

            (ntable)        __ip_match ANY -V change ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (route)         __ip_match ANY -V add append change delete flush get list show=list replace ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (add|append|change|replace) STATE+=+A/=dev/PREFIX0/route+R ;;
                            (delete)                    STATE+=+A/=dev/PREFIX0/route+R ;;
                            (get)                       STATE+=+get/ADDR   ;;
                            (flush|list|show)           STATE+=+L ;;
                            esac
                            ;;

            (route+R)       __ip_match ANY -V blackhole==RTYPE broadcast==RTYPE local==RTYPE multicast==RTYPE nat==RTYPE prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE ||
                            __ip_match_empty
                            __ip_debug_parsing_state P4
                            STATE=route+A
                            ;;

            (route+A)       __ip_match ANY -V blackhole==RTYPE broadcast==RTYPE default dev iif local==RTYPE multicast==RTYPE nat==RTYPE oif=dev prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE via weight ||
                            __ip_match_failed
                            case $_V in
                            (default)       STATE+= ;;
                            (via)           STATE+=/ADDR ;;
                            (dev|iif|oif)   STATE+=/DEVICE ;;
                            (weight)        STATE+=/NUMBER ;;
                            (blackhole)     STATE+=/PREFIX0 ;;
                            (broadcast)     STATE+=/PREFIX0 ;;
                            (local)         STATE+=/PREFIX0 ;;
                            (multicast)     STATE+=/PREFIX0 ;;
                            (nat)           STATE+=/PREFIX0 ;;
                            (prohibit)      STATE+=/PREFIX0 ;;
                            (throw)         STATE+=/PREFIX0 ;;
                            (unicast)       STATE+=/PREFIX0 ;;
                            (unreachable)   STATE+=/PREFIX0 ;;
                            esac
                            ;;

            (route+L)       __ip_match ANY -V exact match proto root scope table type ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (exact)         STATE+=/PREFIX0   ;;
                            (match)         STATE+=/PREFIX0   ;;
                            (proto)         STATE+=/RTPROTO  ;;
                            (root)          STATE+=/PREFIX0   ;;
                            (scope)         STATE+=/SCOPE    ;;
                            (table)         STATE+=/TABLE+   ;;
                            (type)          STATE+=/RTYPE    ;;
                            esac
                            ;;

            (route+get)     __ip_match ANY -V from oif tos ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (from)          STATE+=/=iif/ADDR ;;
                            (dev|iif|oif)   STATE+=/DEVICE    ;;
                            (tos)           STATE+=/TOS       ;;
                            esac
                            ;;

            (route+P)     # ROUTE -> NODE_SPEC -> [RTYPE] PREFIX
                            __ip_match ANY -V advmss cwnd dev equalize initcwnd metric mtu nexthop oif=dev proto realms rto_min rtt rttvar scope src ssthresh table tos via weight window ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (advmss|weight)     STATE+=/NUMBER16 ;;
                            (cwnd|initcwnd|mtu) STATE+=/NUMBER32 ;;
                            (dev)               STATE+=/DEVICE   ;;
                            (equalize|onlink|pervasive)         ;;
                            (metric)            STATE+=/NUMBER31S ;;
                            (nexthop)           unset ${!__ip_seen_*} ;;  # reset the "already seen" list
                            (proto)             STATE+=/RTPROTO  ;;
                            (realms)            STATE+=/REALM    ;;  # TODO maybe this should be REALMPAIR?
                            (rto_min|rtt|rttvar) STATE+=/TIME    ;;
                            (scope)             STATE+=/SCOPE    ;;
                            (src|via)           STATE+=/ADDR     ;;
                            (ssthresh)          STATE+=/NUMBER   ;;
                            (table)             STATE+=/TABLE    ;;
                            (tos)               STATE+=/TOS      ;;
                            (window)            STATE+=/NUMBER8  ;;
                            esac
                            ;;

            (rule)          __ip_match ANY -V add delete flush list show=list ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            STATE+=+$_V
                            ;;

            (rule+list)     __ip_match ANY '# no more args allowed' ' ' ;;  # no args allowed

            (rule+*)        __ip_match ANY -R -V dev from fwmark goto iif=dev lookup not pref prio prohibit realms reject table to tos unreachable ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (dev)           STATE+=/DEVICE   ;;
                            (from|to)       STATE+=/PREFIX0  ;;
                            (fwmark)        STATE+=/FWMARK+MASK ;;
                            (goto|pref|prio) STATE+=/NUMBER  ;;
                            (lookup|table)  STATE+=/TABLE    ;;
                            (not|prohibit|reject|unreachable) ;;
                            (realms)        STATE+=/REALMPAIR ;;
                            (tos)           STATE+=/TOS      ;;
                            esac
                            ;;

            (tunnel)        __ip_match ANY -V 6rd add change del delete=del list=show prl show ||
                            __ip_match_failed
                            STATE+=+$_V/=name
                            ;;

            (tunnel+*)      case $expecting in
                            (*+6rd) __ip_match ANY -R -V 6rd-prefix 6rd-relay_prefix 6rd-reset ;;
                            (*+prl) __ip_match ANY -R -V prl-default prl-delete prl-nodefault ;;
                            (*) false ;;
                            esac ||
                            __ip_match ANY -R -V dev icsum ikey iseq local mode nopmtudisc==pmtudisc ocsum oif=dev okey oseq pmtudisc remote tos ttl ||
                            __ip_match_failed
                            __ip_debug_parsing_state P4
                            case $_V in
                            (icsum|iseq|ocsum|oseq|nopmtudisc|pmtudisc) ;;
                            (6rd-reset) ;;
                            (6rd-*|local|prl-*|remote)
                                            STATE+=/ADDR    ;;
                            (dev|oif)       STATE+=/DEVICE  ;;
                            (ikey|okey)     STATE+=/KEY     ;;
                            (mode)          STATE+=/TMODE   ;;
                            (name)          STATE+=/NAME    ;;
                            (tos)           STATE+=/TOS     ;;
                            (ttl)           STATE+=/TTL     ;;
                            esac
                            ;;

            (KEY)           __ip_match_addr -Finet || __ip_match NUM || __ip_match_failed ;;
            (TOS)           __ip_match NUM -V                   || __ip_match ANY inherit || __ip_match_failed ;;
            (TTL)           __ip_match NUM -V --min=1 --max=255 || __ip_match ANY inherit || __ip_match_failed ;;

            (TMODE)         __ip_match ANY ipip gre sit || __ip_match_failed ;;

            (xfrm)          __ip_match ANY -V policy state monitor || __ip_match_failed
                            STATE+=+$_V
                            ;;

            (xfrm+*)        __ip_match_failed
                            ;; # TODO

            (NAME)          __ip_match ANY "$cur " "$cur..." || __ip_match_failed ; __ip_seen_NAME=true ;;
            (ADDR)          __ip_match_addr $save_family     || __ip_match_failed ;;
            (MADDR)         __ip_match_addr $save_family -m  || __ip_match_failed ;;
            (LLADDR)        __ip_match_addr -Flink           || __ip_match_failed ;;
            (PREFIX0)       __ip_match_addr $save_family -pd || __ip_match_failed ; __ip_seen_PREFIX=true ;;
            (PREFIX)        __ip_match_addr $save_family -p  || __ip_match_failed ; __ip_seen_PREFIX=true ;;

            (DEVICE)        __ip_match ANY -Vsave_device $(ip -o link list | sed -e "s/^[0-9]*: //; s/: .*//; /^wmaster/d" ) ||
                            __ip_match_failed ;;
            (FWMARK+MASK)   case $cur in
                            (*/*/*) false ;;
                            (*)    __ip_match NUM -I'*/' --32bit ;;
                            esac ||
                            __ip_match_failed ;;
            (LIFETIME)      __ip_match ANY forever ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;

            (NUDSTATE)      __ip_match ANY noarp permanent reachable stale || __ip_match_failed ;;

            (NUM:*:*)       max_num=${expecting#NUM:} ; min_num=${max_num%:*} max_num=${max_num#*:}
                            __ip_match NUM --min=$min_num --max=$max_num || __ip_match_failed ;;
            (NUM:*)         __ip_match NUM --max=${expecting##*:}        || __ip_match_failed ;;
            (NUMBER)        __ip_match NUM                               || __ip_match_failed ;;
            (NUMBER8)       __ip_match NUM --8bit                        || __ip_match_failed ;;
            (NUMBER16)      __ip_match NUM --16bit                       || __ip_match_failed ;;
            (NUMBER32)      __ip_match NUM --32bit                       || __ip_match_failed ;;
            (NUMBER31S)     __ip_match NUM --signed32bit                 || __ip_match_failed ;;
            (ONOFF)         __ip_match ANY on off                               || __ip_match_failed ;;
            (QOSMAP)        case $cur in
                            (*[^0-9:]*|*:*:*) false ;;
                            (*)   __ip_match NUM -I'*:' ;;
                            esac || __ip_match_failed ;;
            (REALMPAIR)     case $cur in
                            (*/*/*) false ;;
                            (*)     __ip_match NUM -I'*/' --8bit ||
                                    __ip_match ANY -C${cur#*/} $( __ip_slurp /etc/iproute2/rt_realms ) ;;
                            esac ||
                            __ip_match_failed ;;
            (REALM)         __ip_match NUM --8bit ||
                            __ip_match ANY $( __ip_slurp /etc/iproute2/rt_realms ) ||
                            __ip_match_failed ;;
            (SCOPE)         __ip_match NUM --8bit ||
                            __ip_match ANY $( __ip_slurp /etc/iproute2/rt_scopes ) ||
                            __ip_match_failed ;;
            (LABEL)         __ip_match ANY $save_device: || true ;;
            (TABLE)         __ip_match NUM --8bit ||
                            __ip_match ANY default local main $( __ip_slurp /etc/iproute2/rt_tables ) ||
                            __ip_match_failed ;;
            (TABLE+)        __ip_match NUM --max=255 --min=-2 ||
                            __ip_match ANY all default local main $( __ip_slurp /etc/iproute2/rt_tables ) ||
                            __ip_match_failed ;;
            (RTYPE)         __ip_match ANY -R blackhole==RTYPE broadcast==RTYPE local==RTYPE multicast==RTYPE nat==RTYPE prohibit==RTYPE throw==RTYPE unicast==RTYPE unreachable==RTYPE ||
                            __ip_match_failed ;;
            (RTPROTO)       __ip_match ANY -R boot==RTPROTO kernel==RTPROTO static==RTPROTO ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;
            (TOS)           __ip_match ANY inherit ||
                            __ip_match NUM --8bit ||
                            __ip_match_failed ;;

            (*)             __ip_error "Lost sync? STATE=$STATE expect=$expecting cur=$cur" ;;

            esac  # }}}

            __ip_debug_parsing_state P5

        done  # }}}

        __ip_debug "COMPREPLY=[${COMPREPLY[*]}] (after compgen)"

        ((${#COMPREPLY[@]} == 0)) && __ip_warning "No matches for '$cur'"

        # completion treats some punctuation as if they were word-separators, and appends to current word rather than replacing it
        if [[ -n "$COMP_WORDBREAKS" && $cur = *[$COMP_WORDBREAKS]* ]]
        then
            local rword_index
            cur="${cur%"${cur##*[$COMP_WORDBREAKS]}"}"
            for ((rword_index=0 ; rword_index<${#COMPREPLY[@]} ; rword_index++ )) do
                COMPREPLY[rword_index]="${COMPREPLY[rword_index]#"$cur"}"
            done
        fi

        unset ${!__ip_seen_*}
        return 0
    done  # }}} end dummy loop
    COMPREPLY=()
    __ip_debug_parsing_state '***ABORT***'
    #__ip_unexpected "Lost sync? STATE=$STATE expect=$expecting cur=$__cur"
    unset ${!__ip_seen_*}
    [[ $COMP_TYPE = best ]] && COMP_TYPE=9
    return 1
}
complete -F _ip -o nospace ip
